\documentclass[11pt,a5paper]{article}

\title{A general invariant manifold construction procedure,
including isochrons of slow manifolds}

\author{A.~J. Roberts\thanks{School of Mathematical
Sciences, University of Adelaide, South Australia~5005,
\textsc{Australia}. \url{https://profajroberts.github.io/}}}

\date{Nov 2013 -- \today}



\usepackage{url,natbib,amsmath,defns,reducecode}
\RaisedNamesfalse
\let\harvardurl\url
\IfFileExists{ajr.sty}{\usepackage{ajr}}{}
\usepackage{mycleveref}
\Vec u\Vec e\Vec z\Vec s
\Cal L \Cal E \Cal Z
\def\dde{\textsc{dde}}% delay diff equation
\newcommand{\adj}[1]{#1^\dagger} % denotes cc transpose
% following is for output of coordinate transform
\def\cis\big(#1\big){\,e^{#1i}}
\def\eps{\varepsilon}

\begin{document}
\sloppy

\maketitle

\begin{abstract}
This procedure constructs a specified invariant manifold for
a specified system of ordinary differential equations or
delay differential equations. The invariant manifold may be
any of a centre manifold, a slow manifold, an un/stable
manifold, a sub-centre manifold, a nonlinear normal form,
any spectral submanifold, or indeed a normal form coordinate
transform of the entire state space. Thus the procedure may
be used to analyse pitchfork bifurcations, or oscillatory
Hopf bifurcations, or any more complicated superposition. In
the cases when the neglected spectral modes all decay, the
constructed invariant manifold supplies a faithful large
time model of the dynamics of the differential equations.
Further, in the case of a slow manifold, this procedure now
derives vectors defining the projection onto the invariant
manifold along the isochrons: this projection is needed for
initial conditions, forcing, system modifications, and
uncertainty quantification.
\end{abstract}

\tableofcontents



\section{Introduction}

Download and install the computer algebra package
\emph{Reduce} via \url{http://www.reduce-algebra.com}\quad
Download and unzip the folder
\url{https://profajroberts.github.io/InvariantManifold.zip}
\quad Within the folder \verb|InvariantManifold|, start-up
\emph{Reduce} and load the procedure by executing the
command \verb|in_tex "invariantManifold.tex"$|
\footnote{This script changes a lot of internal settings of
\emph{Reduce}, so best only to do when needed.} Test your
installation by then executing \verb|exampleslowman();|

Thereafter, construct a specified invariant manifold of a
specific dynamical system by executing the following command
with specific values for the input parameters.  See
\verb|allExamples.pdf| for many examples.
\begin{verbatim}
invariantmanifold(odefns, evals, evecs, adjvecs, toosmall);
\end{verbatim}

\paragraph{Inputs}
As in the example of the next \cref{ss:eg}, the input
parameters to the procedure are the following:
\begin{itemize}

\item \verb|odefns|, a comma separated list within
\verb|mat((...))|, the \textsc{rhs} expressions of the
\textsc{ode}s/\textsc{dde}s of the system, a system
expressed in terms of variables \verb|u1|, \verb|u2|,
\ldots, for time derivatives \(\de t{\tt u1}\), \(\de t{\tt
u2}\), \ldots;

any time delayed variables in the \textsc{rhs} are coded by
the time-delay in parenthesises after the variable, as in
the example~\verb|u1(pi/2)| to represent~\(u_1(t-\pi/2)\) in
the \textsc{dde}s;

\item \verb|evals|, a comma separated list within
\verb|mat((...))|, the eigenvalues of the modes to be the
basis for the invariant manifold;

\item \verb|evecs|, a comma separated list of vectors within
\verb|mat(...)|---each vector a comma separated list of
components within \verb|(...)|, the eigenvectors of the
modes corresponding to the given eigenvalues of the
invariant manifold basis;

\item \verb|adjvecs|, a comma separated list of vectors
within \verb|mat(...)|, usually the adjoint eigenvectors of
the modes corresponding to the given eigenvalues of the
invariant manifold basis;  

\item \verb|toosmall|, an integer giving the desired order
of error in the asymptotic approximation that is
constructed.  The procedure embeds the specified system in a
family of systems parametrised by~\(\eps\), and constructs
an invariant manifold, and evolution thereon, of the
embedding system to the asymptotic error~\Ord{\eps^{\tt
toosmall}} (as \(\eps\to0\)). Often the introduced
artificial~\(\eps\) has a useful physical meaning, but
strictly you should  evaluate the output at \(\eps=1\) to
recover results for the specified system, and then interpret
the results in terms of actual `small' parameters.

\end{itemize}



\paragraph{Outputs}  This procedure reports the specified
system, the embedded system it actually analyses, the number
of iterations taken, the invariant manifold approximation,
the evolution on the invariant manifold, and optionally a
basis for projecting onto the invariant manifold.
\begin{itemize}
\item A plain text report to the Terminal window in which
\verb|Reduce| is executing---the invariant manifold is
parametrised by variables \verb|s(1)|, \verb|s(2)|, \ldots,
and the dynamics by their evolution in time.
\item A \LaTeX\ source report written to the file
\verb|invarManReport.tex| (and
\verb|invarManReportSys.tex|)---the invariant manifold is
parametrised by variables \(s_1\), \(s_2\), \ldots, and the
dynamics by their evolution in time.  Generate a pdf version
by executing \verb|pdflatex invarManReport|\,.
\end{itemize}
One may change the appearance of the output somewhat. For
example, it is often useful to execute  \verb|factor s;|
before executing \verb|invariantmanifold(...)| in order to
group terms with the same powers of amplitudes\slash
order-parameters\slash coarse-variables.


\paragraph{Background}
The theoretical support for the results of the analysis of
this procedure is centre\slash stable\slash unstable
manifold theory \cite[e.g.,][]{Carr81, Haragus2011,
Roberts2014a}, and an embryonic backwards theory
\cite[]{Roberts2018a}. This particular procedure is
developed from a coordinate-independent algorithm for
constructing centre manifolds originally by
\cite{Coullet83}, adapted for human-efficient computer
algebra by \cite{Roberts96a}, extended to invariant\slash
inertial manifolds \cite[]{Roberts89, Foias88b}, and further
extended to the projection of initial conditions, forcing,
uncertainty via the innovations of \cite{Roberts89b,
Roberts97b}.



\subsection{A simple example: \texttt{exampleslowman()}} 
\label{ss:eg}
Execute this example by invoking the command
\verb|exampleslowman();|\quad The example system to analyse
is specified to be \cite[Example~2.1]{Roberts2014a}
\begin{equation*}
\dot u_1=-u_1+u_2-u_1^2\,, \quad \dot u_2=u_1-u_2+u_2^2\,.
\end{equation*}
\begin{reduce}
procedure exampleslowman;  
    invariantmanifold(
    mat((-u1+u2-u1^2,u1-u2+u2^2)),
    mat((0)),
    mat((1,1)),
    mat((1,1)),
    5)$
\end{reduce}
We seek the slow manifold so specify the eigenvalue zero.
From the linearisation matrix~\(\begin{bmat} -1&1 \\ 1&-1
\end{bmat}\) a corresponding eigenvector is \(\ev=(1,1)\),
and a corresponding left-eigenvector is \(\zv=\ev=(1,1)\),
as specified. The last parameter specifies to construct the
slow manifold to errors~\Ord{\eps^5}.

The procedure actually analyses the embedding system, the
family of problems,
\begin{equation*}
\dot u_1=-u_1+u_2-\eps u_1^2\,, \quad \dot u_2=u_1-u_2+\eps u_2^2\,.
\end{equation*}
Here the artificial parameter~\(\eps\) has a physical
interpretation in that it counts the nonlinearity: a term
in~\(\eps^p\) will be a \((p+1)\)th~order term
in~\(\uv=(u_1,u_2)\). Hence the specified error~\Ord{\eps^5}
is here the same as error~\Ord{|\sv|^6}.

The constructed slow manifold is, in terms of the
parameter~\(s_1\) (and reverse ordering!), 
\begin{align*}&
u_{1}=3/8 \eps^{3} s_{1}^{4}-1/2 \eps s_{1}^{2}+s_{1}\,,
\\&
u_{2}=-3/8 \eps^{3} s_{1}^{4}+1/2 \eps s_{1}^{2}+s_{1}\,.
\end{align*}
On this slow manifold the evolution is
\begin{equation*}
\dot s_{1}=-3/4 \eps^{4} s_{1}^{5}+\eps^{2} s_{1}^{3}\,:
\end{equation*}
here the leading term in~\(s_1^3\) indicates the origin is
unstable. To project initial conditions onto the slow
manifold, or non-autonomous forcing, or modifications of the
original system, or to quantify uncertainty, use the
projection defined by the derived vector
\begin{equation*}
\zv_1=\begin{bmatrix}z_{11}\\z_{12}\end{bmatrix}
=\begin{bmatrix}
3/2 \eps^{4} s_{1}^{4}+3/4 \eps^{3} s_{1}^{3}-1/2 \eps^{2} s_{1}
^{2}-1/2 \eps s_{1}+1/2
\\
3/2 \eps^{4} s_{1}^{4}-3/4 \eps^{3} s_{1}^{3}-1/2 \eps^{2} s_{1}
^{2}+1/2 \eps s_{1}+1/2
\end{bmatrix}.
\end{equation*}
Evaluate these at \(\eps=1\) to apply to the original
specified system, or here just interpret~\(\eps\) as a way
to count the order of each term.




\subsection{Header of the procedure}

Need a couple of things established before defining the
procedure: the \verb|rlfi| package; and operator names for
the variables of the dynamical system (in case they have
delays)---currently code a max of nine variables.
\begin{reduce}
load_package rlfi; 
operator u1,u2,u3,u4,u5,u6,u7,u8,u9;
\end{reduce}

Now define the procedure as an operator so we can define
procedures internally, and may be flexible with its
arguments.
\begin{reduce}
operator invariantmanifold;
for all odefns, evals, evecs, adjvecs, toosmall let
  invariantmanifold(odefns, evals, evecs, adjvecs, toosmall) 
  = begin 
\end{reduce}


\subsection{Preamble to the procedure}
Operators and arrays are always global, but we can make
variables and matrices local, except for matrices that need
to be declared \verb|matrix|.  So, move to implement all
arrays and operators to have underscores, and almost all
scalars and most matrices to be declared local here.
\begin{reduce}
scalar ff, evalm, ee, zz, maxiter, ff0, trace, ll, uvec,
reslin, ok, rhsjact, jacadj, resd, resde, resz, rhsfn, zs,
pp, est, eyem;
\end{reduce}

Write an intro message.
\begin{reduce}
write "Construct an invariant manifold (version 8 Apr 2021)"$
\end{reduce}


Transpose the defining matrices so that vectors are columns.
\begin{reduce}
ff := tp odefns;
ee := tp evecs;
zz := tp adjvecs; 
\end{reduce}


Define default parameters for the iteration:
\verb|maxiter|~is the maximum number of allowed iterations.
Specific problems may override these defaults.
\begin{reduce}
maxiter:=29$
factor small; 
\end{reduce}

For optional trace printing of test cases: comment out
second line when not needed.
\begin{reduce}
trace:=0$
%trace:=1; maxiter:=5; 
\end{reduce}


The \verb|rationalize| switch makes code much faster with
complex numbers. The switch \verb|gcd| seems to wreck
convergence, so leave it off.
\begin{reduce}
on div; off allfac; on revpri; 
on rationalize;
\end{reduce}

Use \verb|e_| as basis vector for matrices and vectors.
Declare it non-commutative so that multiplication does not
commute.
\begin{reduce}
operator e_;
noncom e_;
factor e_;
let { e_(~j,~k)*e_(~l,~m)=>0 when k neq l
    , e_(~j,~k)*e_(~l,~m)=>e_(j,m) when k=l 
    , e_(~j,~k)^2=>0 when j neq k
    , e_(~j,j)^2=>e_(j,j) };
\end{reduce}
Also need (once) a transpose operator: do complex
conjugation explicitly when needed.
\begin{reduce}
operator tpe_; linear tpe_;
let tpe_(e_(~i,~j),e_)=>e_(j,i);
\end{reduce}




Empty the output LaTeX file in case of error.
\begin{reduce}
out "invarManReport.tex";
write "This empty document indicates error.";
shut "invarManReport.tex";
\end{reduce}


 


\subsection{Check the dimensionality of specified system}
Extract dimension information from the parameters of the
procedure: seek $m$D~invariant manifold of an $n$D~system.
\begin{reduce}
write "total no. of variables ",
n:=part(length(ee),1);
write "no. of invariant modes ",
m:=part(length(ee),2);
if {length(evals),length(zz),length(ee),length(ff)}
  ={{1,m},{n,m},{n,m},{n,1}} 
  then write "Input dimensions are OK" 
  else <<write "INCONSISTENT INPUT DIMENSIONS, I EXIT"; 
      return>>;
\end{reduce}

For the moment limit to a maximum of nine components.
\begin{reduce}
if n>9 then <<write "SORRY, MAX NUMBER ODEs IS 9, I EXIT"; 
    return>>;
\end{reduce}

Need an \(m\times m\)~identity matrix for normalisation of
the isochron projection.
\begin{reduce}
eyem:=for j:=1:m sum e_(j,j)$
\end{reduce}


\section{Dissect the linear part}

Use the exponential $\verb|exp|(u)=e^{u}$, but not with the
myriad of inbuilt properties so clear it! Do not (yet)
invoke the simplification of $\verb|exp|(0)$ as I want it to
label modes of no oscillation, zero eigenvalue.
\begin{reduce}
clear exp; operator exp;
let { df(exp(~u),t) => df(u,t)*exp(u)
    , exp(~u)*exp(~v) => exp(u+v)
    , exp(~u)^~p => exp(p*u)
    };
\end{reduce}

Need function~\verb|conj_| to do parsimonious complex
conjugation.   
\begin{reduce}
procedure conj_(a)$ sub(i=-i,a)$
\end{reduce}

Make an array of eigenvalues for simplicity (\verb|evals|
not used hereafter).
\begin{reduce}
array eval_(m);
for j:=1:m do eval_(j):=evals(1,j);
\end{reduce}



\subsection{Normalise the adjoint eigenvectors}
When we include delay differential equations, then we need
to account for the history of the eigenvector as well. Hence
multiply each eigenvector by its oscillating
factor,~\(e^{i\omega t}, e^{\lambda t}\), and then take the
mean. This multiplication by its oscillating factor should
not make any difference for non-delay equations by the
natural orthogonality of left and right eigenvectors of
different eigenvalues. 
%Reduce implements \verb|conj| via \verb|repart|
%and \verb|impart|, so let \verb|repart| do the conjugation
%of the exp factors.

Note: the `left eigenvectors' have to be the eigenvectors of
the complex conjugate transpose, and for the complex
conjugate eigenvalue. This seems best: for example, when the
linear operator is \(\begin{bmat} 0&1\\-1&0 \end{bmat}\)
then the adjoint and the right eigenvectors are the same.

For oscillations and un/stable manifolds we have to cope
with imaginary and with real eigenvalues. Seems to need
\verb|zz| to have negative complex conjugated frequency so
store in~\verb|cexp_|---cannot remember why this appears to
work!?  It may only work for pure real and for pure
imaginary eigenvalues??

\begin{reduce}
matrix aa_(m,m),dexp_(m,m),cexp_(m,m);
for j:=1:m do dexp_(j,j):=exp(eval_(j)*t);
for j:=1:m do cexp_(j,j):=exp(-conj_(eval_(j))*t); 
aa_:=(tp map(conj_(~b),ee*dexp_)*zz*cexp_ )$
if trace then write aa_:=aa_;
write "Normalising the left-eigenvectors:";
aa_:=(aa_ where {exp(0)=>1, exp(~a)=>0 when a neq 0})$
if trace then write aa_:=aa_;
if det(aa_)=0 then << write
    "ORTHOGONALITY ERROR IN EIGENVECTORS; I EXIT"; 
    return>>;
zz:=zz*aa_^(-1);
\end{reduce}


\subsection{Operator to represent delays}

Introduce an operator to represent delay factors more
conveniently for analysis.  The \verb|exp| rule probably
only works for pure imaginary modes!?
\begin{reduce}
operator d_; linear d_;
let { d_(~a^~p,t,~dt)=>d_(a,t,dt)^p
    , d_(~a*~b,t,~dt)=>d_(a,t,dt)*d_(b,t,dt)
    , d_(exp(~a),t,~dt)=>exp(a)
        *sub(t=-dt,cos(-i*a)+i*sin(-i*a))
    , df(d_(~a,t,~dt),~b)=>d_(df(a,b),t,dt)
    , d_(~a,t,0)=>a
    , d_(d_(~a,t,~dta),t,~dtb)=>d_(a,t,dta+dtb)
    };
\end{reduce}

Now rewrite the (delay) factors in terms of this operator.
For the moment limit to a maximum of nine \ode{}s.
\begin{reduce}
somerules:={}$
depend u1,t; somerules:=(u1(~dt)=d_(u1,t,dt)).somerules$
depend u2,t; somerules:=(u2(~dt)=d_(u2,t,dt)).somerules$
depend u3,t; somerules:=(u3(~dt)=d_(u3,t,dt)).somerules$
depend u4,t; somerules:=(u4(~dt)=d_(u4,t,dt)).somerules$
depend u5,t; somerules:=(u5(~dt)=d_(u5,t,dt)).somerules$
depend u6,t; somerules:=(u6(~dt)=d_(u6,t,dt)).somerules$
depend u7,t; somerules:=(u7(~dt)=d_(u7,t,dt)).somerules$
depend u8,t; somerules:=(u8(~dt)=d_(u8,t,dt)).somerules$
depend u9,t; somerules:=(u9(~dt)=d_(u9,t,dt)).somerules$
ff:=(ff where somerules)$
\end{reduce}


\subsection{Linearise at the origin}

Assume the equilibrium is at the origin. Find the linear
operator at the equilibrium.  Include \verb|small=0| as we
notionally adjoin it in the list of variables.  Do not need
to here make any non-zero forcing small at the equilibrium
as it gets multiplied by \verb|small| later.  (For some
reason using \verb|mkid(u,k)=>0| does not resolve the mkid,
but \verb|mkid(u,k)=0| does; however, not clear if it is a
problem.)
\begin{reduce}
ll:=ee*(tp ee)*0; %zero nxn matrix
uzero:=(for k:=1:n collect (mkid(u,k)=0))$
equilibrium:=(small=0).uzero$
for j:=1:n do for k:=1:n do begin 
  ll(j,k):=df(ff(j,1),mkid(u,k));
  ll(j,k):=sub(equilibrium,ll(j,k));
end;
write "Find the linear operator is";
write ll:=ll;
\end{reduce}

We need a vector of unknowns for a little while.
\begin{reduce}
uvec:=0*ff; %nx1 zero matrix
for j:=1:n do uvec(j,1):=mkid(u,j);
\end{reduce}


\subsection{Eigen-check}

Variable \verb|aa_| appears here as the diagonal matrix of
eigenvalues. Check that the eigenvalues and eigenvectors are
specified correctly.
\begin{reduce}
write "Check invariant subspace linearisation ";
for j:=1:m do for k:=1:m do aa_(j,k):=0;
for j:=1:m do aa_(j,j):=eval_(j);
% following maybe only for pure centre modes??
reslin:=(ll*(ee*dexp_)-(ee*dexp_)*aa_
    where exp(~a)*d_(1,t,~dt)=>sub(t=-dt,cos(-i*a)+i*sin(-i*a))*exp(a) )$ 
if trace then write reslin:=reslin;
ok:=1$
for j:=1:n do for k:=1:m do 
    ok:=if reslin(j,k)=0 then ok else 0$
if ok then write "Linearisation is OK";
\end{reduce}

Try to find a correction of the linear operator that is
`close'. Multiply by the adjoint eigenvectors and then
average over time: operator \(\cL_{\text{new}} := \cL
-\cL_{\text{adj}}\) should now have zero residual. Lastly,
correspondingly adjust the \ode{}s, since \verb|lladj| does
not involve delays we do not need delay operator transforms
in the product.
\begin{reduce}
if not ok then for iter:=1:2 do begin
write "WARNING: I NEED TO ADJUST LINEAR OPERATOR";
write
lladj:=reslin*tp map(conj_(~b),zz*cexp_);
write
lladj:=(lladj where {exp(0)=>1, exp(~a)=>0 when a neq 0});
write
ll:=ll-lladj;
% following maybe only for pure centre modes??
write
reslin:=(ll*(ee*dexp_)-(ee*dexp_)*aa_
    where exp(~a)*d_(1,t,~dt)=>sub(t=-dt,cos(-i*a)+i*sin(-i*a))*exp(a) ); 
ok:=1$
for j:=1:n do for k:=1:m do 
    ok:=if reslin(j,k)=0 then ok else 0$
if ok then iter:=iter+1000;
end;
if not ok then << write
    "OOPS, INCONSISTENT EIGENVALUES, EIGENVECTORS AND OPERATOR.
    EMAIL ME; I EXIT"; 
    return >>;
\end{reduce}




\subsection{Ameliorate the nonlinearity}

Anything not in the linear operator gets multiplied by
\verb|small| to be treated as small in the analysis. The
feature of the second alternative is that when a user
invokes~\verb|small| then the power of smallness is not then
changed; however, causes issues in the relative scaling of
some terms, so restore to the original version. This might
need reconsidering??  The current \verb|if| always chooses
the first simple alternative.
\begin{reduce}
somerules:=for j:=1:n collect 
  (d_(1,t,~dt)*mkid(u,j)=d_(mkid(u,j),t,dt))$
ll0_:=(ll*uvec where somerules)$
ff:=(if 1 then small*ff
           else ff-(1-small)*sub(small=0,ff)) 
    +(1-small)*ll0_$
\end{reduce}

Any constant term in the equations~\verb|ff| has to be
multiplied by~\verb|exp(0)|.
\begin{reduce}
ff0:=(ff where uzero)$
ff:=ff+(exp(0)-1)*ff0$
\end{reduce}

From the matrix versions of the equations, create algebraic
form using the matrix basis.
\begin{reduce}
rhsfn:=for i:=1:n sum e_(i,1)*ff(i,1)$
\end{reduce}

Also, create the algebraic form of the jacobian transpose
using the matrix basis: take the conjugate later when used.
\begin{reduce}
rhsjact:=for i:=1:n sum for j:=1:n sum 
    e_(j,i)*df(ff(i,1),mkid(u,j))$
\end{reduce}




\subsection{Store invariant manifold eigenvalues}

Extract all the eigenvalues in the invariant manifold, and
the set of all the corresponding modes in the invariant
manifold variables. The slow modes are accounted for as
having zero eigenvalue. Remember the eigenvalue set is not in
the `correct' order. Array \verb|modes_| stores the set of
indices of all the modes of a given eigenvalue.
\begin{reduce}
array eval_s(m),modes_(m); 
neval:=0$ eval_set:={}$ 
for j:=1:m do if not(eval_(j) member eval_set) then begin
  neval:=neval+1; 
  eval_s(neval):=eval_(j);
  eval_set:=eval_(j).eval_set;
  modes_(neval):=for k:=j:m join 
    if eval_(j)=eval_(k) then {k} else {};
end;
\end{reduce}

Set a flag for the case of a slow manifold when all
eigenvalues are zero, as then we compute the isochron
projection. The next challenge is to get this isochron code
working for the case of non-slow invariant manifolds.
\begin{reduce}
itisSlowMan_:=if eval_set={0} then 1 else 0$
if trace then write itisSlowMan_:=itisSlowMan_;
\end{reduce}

Put in the non-singular general case as the zero entry of
the arrays.
\begin{reduce}
eval_s(0):=geneval$
modes_(0):={}$
\end{reduce}





\subsection{Precompute matrices for updates}

Precompute matrices to solve for updates for each of the
critical eigenvalues, and the general case $\verb|k|=0$. The
matrix 
\begin{equation*}
\verb|llzz_| = \begin{bmatrix} -\cL+\partial_t & \cE_0 
\\ \adj\cZ_0 & 0 \end{bmatrix}
\end{equation*}
and then put its inverse in place. Subsequently, extract the
blocks for the generalised inverses and solvability
condition into \verb|l_invs| and~\verb|g_invs|.
\begin{reduce}
matrix llzz_(n+m,n+m);
array l_invs(neval),g_invs(neval);
array l1_invs(neval),g1_invs(neval),l2_invs(neval),g2_invs(neval);
operator sp_; linear sp_;
for k:=0:neval do begin
  if trace then write "ITERATION ",k:=k; 
\end{reduce}

Code the operator \(\cL\hat v\) where the delay is to only
act on the oscillation part.
\begin{reduce}
  for ii:=1:n do for jj:=1:n do llzz_(ii,jj):=(
      -sub(small=0,ll(ii,jj)) where d_(1,t,~dt)
      => cos(i*eval_s(k)*dt)+i*sin(i*eval_s(k)*dt));
\end{reduce}

Code the operator \(\D t{\hat v}\) where it only acts on the
oscillation part.
\begin{reduce}
  for j:=1:n do llzz_(j,j):=eval_s(k)+llzz_(j,j);
\end{reduce}

Now code the part leading to the solvability condition which
arises from allowing the (oscillation) amplitude to evolve.
Use operator \verb|sp_| to extract the delay parts that
subtly affect the updates of the evolution.
\begin{reduce}
  for j:=1:length(modes_(k)) do 
    for ii:=1:n do llzz_(ii,n+j):=ee(ii,part(modes_(k),j))
     +(for jj:=1:n sum 
       sp_(ll(ii,jj)*ee(jj,part(modes_(k),j)),d_)
       where { sp_(1,d_)=>0
             , sp_(d_(1,t,~dt),d_)=>dt*(
               cos(i*eval_s(k)*dt)+i*sin(i*eval_s(k)*dt))
             });
\end{reduce}

Force the updates to be orthogonal to the left-eigenvectors
in the complex conjugate transpose adjoint.
\begin{reduce}
  for ii:=1:length(modes_(k)) do for j:=1:n do 
      llzz_(n+ii,j):=conj_(zz(j,part(modes_(k),ii)));
  if trace then write "finished Force the updates to be orthogonal";
\end{reduce}

Set the bottom-right corner of the matrix to zero.
\begin{reduce}
  for i:=1:length(modes_(k)) do 
    for j:=1:m do llzz_(n+i,n+j):=0;
\end{reduce}

Add some trivial rows and columns to make the matrix up to
the same size for all eigenvalues.
\begin{reduce}
  for i:=length(modes_(k))+1:m do begin 
    for j:=1:n+i-1 do llzz_(n+i,j):=llzz_(j,n+i):=0;
    llzz_(n+i,n+i):=1;
  end;
  if trace then write "finished Add some trivial rows and columns";
\end{reduce}

Invert the matrix and unpack into arrays ready for use by
the inversion operators.
\begin{reduce}
  if trace then write llzz_:=llzz_; 
  llzz_:=llzz_^(-1);
  if trace then write llzz_:=llzz_;
  l_invs(k):=for i:=1:n sum for j:=1:n sum e_(i,j)*llzz_(i,j);
  g_invs(k):=for i:=1:length(modes_(k)) sum 
    for j:=1:n sum e_(part(modes_(k),i),j)*llzz_(i+n,j);
if trace then write "finished Invert the matrix and unpack";
\end{reduce}

Unpack the conjugate transpose for inverse operators used
for the isochrons. A difference here is that the
orthogonality condition is non-trivial (in the slow manifold
we assumed amplitudes were exactly orthogonal to the
left-eigenvectors), so we need to remember more parts of the
inverse of the matrix.  
%  realgeneval:={repart(geneval)=>geneval, impart(geneval)=>0}$
\begin{reduce}
  l1_invs(k) := for ii:=1:n sum for j:=1:n sum 
      e_(ii,j)*conj_(llzz_(j,ii));
  l2_invs(k) := for ii:=1:n sum 
      for j:=1:length(modes_(k)) sum 
          e_(ii,part(modes_(k),j))*conj_(llzz_(j+n,ii));
  g1_invs(k) := for ii:=1:length(modes_(k)) sum 
      for j:=1:n sum 
          e_(part(modes_(k),ii),j)*conj_(llzz_(j,ii+n));
  g2_invs(k) := for ii:=1:length(modes_(k)) sum 
      for j:=1:length(modes_(k)) sum 
          e_(part(modes_(k),ii),part(modes_(k),j))
          *conj_(llzz_(j+n,ii+n));
  if trace then write "finished Unpack the conjugate transpose";
end;
\end{reduce}



\subsection{Define operators that invoke these inverses}

Decompose residuals into parts, and operate on each. First
for the invariant manifold. But making \verb|e_|
non-commutative means that it does not get factored out of
these linear operators: must post-multiply by~\verb|e_|
because the linear inverse is a premultiply.
\begin{reduce}
operator l_inv; linear l_inv;
let l_inv(e_(~j,~k)*exp(~a),exp)=>l_invproc(a/t)*e_(j,k);
procedure l_invproc(a);
  if a member eval_set
  then << k:=0; 
    repeat k:=k+1 until a=eval_s(k);
    l_invs(k)*exp(a*t) >>
  else sub(geneval=a,l_invs(0))*exp(a*t)$
\end{reduce}

Second for the evolution on the invariant manifold.
\begin{reduce}
operator g_inv; linear g_inv;
let g_inv(e_(~j,~k)*exp(~a),exp)=>ginv_proc(a/t)*e_(j,k);
procedure ginv_proc(a); 
  if a member eval_set
  then << k:=0; 
    repeat k:=k+1 until a=eval_s(k);
    g_invs(k) >>
  else sub(geneval=a,g_invs(0))$
\end{reduce}

Copy and adjust the above for the projection.  But first
define the generic procedure.  
\begin{reduce}
procedure inv_proc(a,invs);
  if a member eval_set
  then << k:=0; 
    repeat k:=k+1 until a=eval_s(k);
    invs(k)*exp(a*t) >>
  else sub(geneval=a,invs(0))*exp(a*t)$
\end{reduce}

Then define operators that we use to update the projection.
\begin{reduce}
operator l1_inv; linear l1_inv;
operator l2_inv; linear l2_inv;
operator g1_inv; linear g1_inv;
operator g2_inv; linear g2_inv;
let { l1_inv(e_(~j,~k)*exp(~a),exp)
      => inv_proc(a/t,l1_invs)*e_(j,k)
    , l2_inv(e_(~j,~k)*exp(~a),exp)
      => inv_proc(a/t,l2_invs)*e_(j,k)
    , g1_inv(e_(~j,~k)*exp(~a),exp)
      => inv_proc(a/t,g1_invs)*e_(j,k)
    , g2_inv(e_(~j,~k)*exp(~a),exp)
      => inv_proc(a/t,g2_invs)*e_(j,k)
    };
\end{reduce}









\section{Initialise LaTeX output}
% AJR, 21 aug 2012 -- Aug 2014

Set the default output to be inline mathematics.
\begin{reduce}
mathstyle math;
\end{reduce}

Define the Greek alphabet with \verb|small| as well.
\begin{reduce}
defid small,name="\eps";%varepsilon;
%defid small,name=varepsilon;
defid alpha,name=alpha;
defid beta,name=beta;
defid gamma,name=gamma;
defid delta,name=delta;
defid epsilon,name=epsilon;
defid varepsilon,name=varepsilon;
defid zeta,name=zeta;
defid eta,name=eta;
defid theta,name=theta;
defid vartheta,name=vartheta;
defid iota,name=iota;
defid kappa,name=kappa;
defid lambda,name=lambda;
defid mu,name=mu;
defid nu,name=nu;
defid xi,name=xi;
defid pi,name=pi;
defid varpi,name=varpi;
defid rho,name=rho;
defid varrho,name=varrho;
defid sigma,name=sigma;
defid varsigma,name=varsigma;
defid tau,name=tau;
defid upsilon,name=upsilon;
defid phi,name=phi;
defid varphi,name=varphi;
defid chi,name=chi;
defid psi,name=psi;
defid omega,name=omega;
defid Gamma,name=Gamma;
defid Delta,name=Delta;
defid Theta,name=Theta;
defid Lambda,name=Lambda;
defid Xi,name=Xi;
defid Pi,name=Pi;
defid Sigma,name=Sigma;
defid Upsilon,name=Upsilon;
defid Phi,name=Phi;
defid Psi,name=Psi;
defid Omega,name=Omega;
\end{reduce}


\begin{reduce}
defindex e_(down,down);
defid e_,name="e";
defindex d_(arg,down,down);
defid d_,name="D";
defindex u(down);
defid u1,name="u\sb1"; 
defid u2,name="u\sb2"; 
defid u3,name="u\sb3"; 
defid u4,name="u\sb4"; 
defid u5,name="u\sb5"; 
defid u6,name="u\sb6"; 
defid u7,name="u\sb7"; 
defid u8,name="u\sb8"; 
defid u9,name="u\sb9"; 
defindex s(down);
defid exp,name="\exp";
defindex exp(arg);
\end{reduce}


Can we write the system? Not in matrices apparently. So
define a dummy array \verb|tmp_| that we use to get the
correct symbol typeset.
\begin{reduce}
array tmp_(n),tmp_s(m),tmp_z(m);
defindex tmp_(down);
defindex tmp_s(down);
defindex tmp_z(down);
defid tmp_,name="\dot u";
defid tmp_s,name="\vec e";
defid tmp_z,name="\vec z";
rhs_:=rhsfn$
for k:=1:m do tmp_s(k):={for j:=1:n collect ee(j,k),exp(eval_(k)*t)};
for k:=1:m do tmp_z(k):={for j:=1:n collect zz(j,k),exp(eval_(k)*t)};
\end{reduce}

We have to be shifty here because \verb|rlfi| does not work
inside a loop: so write the commands to a file, and then
input the file.
\begin{reduce}
out "scratchfile.red";
write "off echo;"$  % do not understand why needed in 2021??
write "write ""\)
\paragraph{The specified dynamical system}
\("";";
for j:=1:n do write "tmp_(",j,"):=coeffn(rhs_,e_(",j,",1),1);";
write "write ""\)
\paragraph{Invariant subspace basis vectors}
\("";";
for j:=1:m do write "tmp_s(",j,"):=tmp_s(",j,");";
for j:=1:m do write "tmp_z(",j,"):=tmp_z(",j,");";
write "end;";
shut "scratchfile.red";
\end{reduce}

Now print the dynamical system to the LaTeX sub-file.
\begin{reduce}
write "Ignore the following 15 lines of LaTeX"$
on latex$
out "invarManReportSys.tex"$
in "scratchfile.red"$
shut "invarManReportSys.tex"$
off latex$
\end{reduce}







\section{Linear approximation to the invariant manifold}

But first, write out the possibly adjusted nonlinear
right-hand side function. According to the manual, this will
append to the earlier output to the file.
\begin{reduce}
write "Analyse ODE/DDE system du/dt = ",ff;
\end{reduce}

Parametrise the invariant manifold in terms of these
amplitudes. For this substitution to work, \verb|gg_|
\emph{cannot} be declared scalar as then it gets replaced by
zero here and throughout.  
\begin{reduce}
clear gg_;
operator s; depend s,t;
let df(s(~j),t)=>coeffn(gg_,e_(j,1),1);
\end{reduce}


Invoke the following procedure to substitute whatever the
current approximation is into (nonlinear) expressions.
\begin{reduce}
procedure manifold_(uu);
    for j:=1:n collect mkid(u,j)=coeffn(uu,e_(j,1),1)$
\end{reduce}


The linear approximation to the invariant manifold must be
the following corresponding to the eigenvalues down the
diagonal (even if zero). The amplitudes~$s_j$ are slowly
evolving as they are either slow modes, or the complex
amplitudes of oscillating modes.
\begin{reduce}
uu_:=for j:=1:m sum s(j)*exp(eval_(j)*t)
  *(for k:=1:n sum e_(k,1)*ee(k,j))$
gg_:=0$
if trace then write uu_:=uu_;
\end{reduce}

For some temporary trace printing, where for simplicity
\verb|small| is replaced by~\verb|s|.
\begin{reduce}
procedure matify(a,m,n)$
  begin matrix z(m,n);
    for i:=1:m do for j:=1:n do z(i,j):=coeffn(a,e_(i,j),1);
    return (z where {exp(0)=>1,small=>s}); 
    end$
\end{reduce}

For the isochron may need to do something different with
eigenvalues, but this should work as the inner product is
complex conjugate transpose. The \verb|pp| matrix is
proposed to place the projection residuals in the range of
the isochron. 
\begin{reduce}
zs:=for j:=1:m sum exp(eval_(j)*t)
  *(for k:=1:n sum e_(k,j)*zz(k,j))$
pp:=0$
\end{reduce}




\section{Iteratively construct the invariant manifold}

But first establish the Taylor series in any delay factors
of slow amplitudes.
\begin{reduce}
let d_(s(~k),t,~dt)=>s(k)+(for n:=1:toosmall sum 
        (-dt)^n*df(s(k),t,n)/factorial(n));
\end{reduce}

Truncate expansions to specified order of error (via loop
index trick).
\begin{reduce}
for j:=toosmall:toosmall do let small^j=>0;
\end{reduce}

Iteratively construct the invariant manifold.
\begin{reduce}
write "Start iterative construction of invariant manifold";
for iter:=1:maxiter do begin
if trace then write "
ITERATION = ",iter,"
-------------";
\end{reduce}

Compute residual vector (matrix) of the dynamical system
\cite{Roberts96a}.
\begin{reduce}
resde:=-df(uu_,t)+sub(manifold_(uu_),rhsfn);
if trace then write "resde=",matify(resde,n,1);
\end{reduce}

Get the local directions of the coordinate system on the
curving manifold: store transpose as \(m\times n\)~matrix.
\begin{reduce}
est:=tpe_(for j:=1:m sum df(uu_,s(j))*e_(1,j),e_);
est:=conj_(est);
if trace then write "est=",matify(est,m,n);
\end{reduce}

Compute residual matrix for the isochron projection
\cite{Roberts89b, Roberts97b}. But for the moment, only do
it if the \verb|eval_set| is for slow manifolds.
\begin{reduce}
if itisSlowMan_ then begin
    jacadj:=conj_(sub(manifold_(uu_),rhsjact));
    if trace then write "jacadj=",matify(jacadj,n,n);
    resd:=df(zs,t)+jacadj*zs+zs*pp;
    if trace then write "resd=",matify(resd,n,m);
\end{reduce}

Compute residual of the normalisation of the projection.
\begin{reduce}
    resz:=est*zs-eyem*exp(0);
    if trace then write "resz=",matify(resz,m,m);
end else resd:=resz:=0; % for when not slow manifold
\end{reduce}

Write lengths of residuals as a trace print (remember that
the expression~$0$ has length one).
\begin{reduce}
write lengthRes:=map(length(~a),{resde,resd,resz});
\end{reduce}

Solve for updates---all the hard work is already encoded in
the operators.
\begin{reduce}
uu_:=uu_+l_inv(resde,exp);
gg_:=gg_+g_inv(resde,exp);
if trace then write "gg=",matify(gg_,m,1);
if trace then write "uu=",matify(uu_,n,1);
\end{reduce}

Now update the isochron projection, with normalisation.
\begin{reduce}
if itisSlowMan_ then begin
zs:=zs+l1_inv(resd,exp)-l2_inv(resz,exp);
pp:=pp-g1_inv(resd,exp)+youshouldnotseethis*g2_inv(resz,exp);
if trace then write "zs=",matify(zs,n,m);
if trace then write "pp=",matify(pp,m,m);
end;
\end{reduce}


Terminate the loop once residuals are zero.
\begin{reduce}
showtime;
if {resde,resd,resz}={0,0,0} then write iter:=iter+10000;
end;
\end{reduce}

Only proceed to print if terminated successfully.
\begin{reduce}
if {resde,resd,resz}={0,0,0} 
  then write "SUCCESS: converged to an expansion"
  else <<write "FAILED TO CONVERGE; I EXIT";
    return; >>;
\end{reduce}





\section{Output text version of results}

Once construction is finished, simplify \verb|exp(0)|.
\begin{reduce}
let exp(0)=>1;
\end{reduce}

Invoking switch \verb|complex| improves some of the output
of the complex numbers, but wrecks other parts of the
output.  Best left off.
%\begin{reduce}
%on complex;
%\end{reduce}


Write text results.
\begin{reduce}
write "The invariant manifold is (to one order lower)";
for j:=1:n do write "u",j," = ",
  coeffn(small*uu_,e_(j,1),1)/small;
write "The evolution of the real/complex amplitudes";
for j:=1:m do write "ds(",j,")/dt = ",
  coeffn(gg_,e_(j,1),1);
\end{reduce}

Optionally write the projection vectors.
\begin{reduce}
if itisSlowMan_ then begin
  write "The normals to the isochrons at the slow manifold.
Use these vectors: to project initial conditions
onto the slow manifold; to project non-autonomous
forcing onto the slow evolution; to predict the
consequences of modifying the original system; in
uncertainty quantification to quantify effects on
the model of uncertainties in the original system.";
  for j:=1:m do write "z",j," = ",
    for i:=1:n collect coeffn(zs,e_(i,j),1);
end;
\end{reduce}

Write text results numerically evaluated when expressions
are long.
\begin{reduce}
if length(gg_)>30 then begin
on rounded; print_precision 4$
write "Numerically, the invariant manifold is (to one order lower)";
for j:=1:n do write "u",j," = ",
  coeffn(small*uu_,e_(j,1),1)/small;
write "Numerically, the evolution of the real/complex amplitudes";
for j:=1:m do write "ds(",j,")/dt = ",
  coeffn(gg_,e_(j,1),1);
if itisSlowMan_ then begin
  write "Numerically, normals to isochrons at slow manifold.";
  for j:=1:m do write "z",j," = ",
    for i:=1:n collect coeffn(zs,e_(i,j),1);
end;
off rounded;
end;
\end{reduce}


%There is an as yet unresolved problem in the typesetting
%when the argument of \verb|exp| (eigenvalue) is a rational
%number instead of integer: the numerator has an extra pair
%of parentheses which then makes the typesetting wrong; maybe
%we need a pre-\LaTeX\ filter??



\section{Output LaTeX version of results}
% AJR, 24 aug 2012 -- aug 2014
Change the printing of temporary arrays.
\begin{reduce}
array tmp_zz(m,n);
defid tmp_,name="u";
defid tmp_s,name="\dot s";
defid tmp_z,name="\vec z";
defid tmp_zz,name="z";
defindex tmp_zz(down,down);
\end{reduce}

Gather complicated result
%for k:=1:m do tmp_z(k):=for j:=1:n collect (1*coeffn(zs,e_(j,k),1));
\begin{reduce}
for k:=1:m do for j:=1:n do 
    tmp_zz(k,j):=(1*coeffn(zs,e_(j,k),1));
\end{reduce}

Write to a file the commands needed to write the LaTeX
expressions. Write the invariant manifold to one order lower
than computed.
\begin{reduce}
out "scratchfile.red";
write "off echo;"$ % do not understand why needed in 2021??
write "write ""\)
\paragraph{The invariant manifold}
These give the location of the invariant manifold in
terms of parameters~\(s\sb j\).
\("";";
for j:=1:n do write "tmp_(",j,
  "):=coeffn(small*uu_,e_(",j,",1),1)/small;";
if length(gg_)>30 then begin
write "on rounded; print_precision 4$"$
for j:=1:n do write "tmp_(",j,
  "):=coeffn(small*uu_,e_(",j,",1),1)/small;";
write "off rounded;"$
end;
\end{reduce}

Write the commands to write the ODEs on the invariant
manifold.
\begin{reduce}
write "write ""\)
\paragraph{Invariant manifold ODEs}
The system evolves on the invariant manifold such
that the parameters evolve according to these ODEs.
\("";";
for j:=1:m do write "tmp_s(",j,"):=1*coeffn(gg_,e_(",j,",1),1);";
if length(gg_)>30 then begin
write "on rounded; print_precision 4$"$
for j:=1:m do write "tmp_s(",j,"):=1*coeffn(gg_,e_(",j,",1),1);";
write "off rounded;"$
end;
\end{reduce}

Optionally write the commands to write the projection
vectors on the slow manifold.
\begin{reduce}
if itisSlowMan_ then begin
  write "write ""\)
\paragraph{Normals to isochrons at the slow manifold}
Use these vectors: to project initial conditions
onto the slow manifold; to project non-autonomous
forcing onto the slow evolution; to predict the
consequences of modifying the original system; in
uncertainty quantification to quantify effects on
the model of uncertainties in the original system.
The normal vector \(\vec z\sb j:=(z\sb{j1},\ldots,z\sb{jn})\)
\("";";
  for i:=1:m do for j:=1:n do 
  write "tmp_zz(",i,",",j,"):=tmp_zz(",i,",",j,");";
end;
\end{reduce}

Finish the scratchfile.
\begin{reduce}
write "end;";
shut "scratchfile.red";
\end{reduce}

Execute the scratchfile with the required commands, with
output to the main invariant manifold LaTeX file.
\begin{reduce}
out "invarManReport.tex"$
on latex$
in "scratchfile.red"$
off latex$
shut "invarManReport.tex"$
\end{reduce}






\section{Fin}
That's all folks, so end the procedure. 
\begin{reduce}
return Finished_constructing_invariant_manifold_of_system$ 
end$
\end{reduce}






\section{Override some system procedures}
Bad luck if these interfere with anything else a user might
try to do afterwards!

First define how various tokens get printed.
\begin{reduce}
%load_package rlfi; %must be loaded early
deflist('((!( !\!b!i!g!() (!) !\!b!i!g!)) (!P!I !\!p!i! )
         (!p!i !\!p!i! ) (!E !e) (!I !i) (e !e) (i !i)),'name)$
\end{reduce}

Override the procedure that prints annoying messages about
multicharacter symbols. It ends the output of one
expression. This is just a copy from \verb|rlfi.red| with
the appropriate if-statement deleted. While interfering,
hardcode that the mathematics is in inline mode.
\begin{reduce}
%write "Ignore immediately following messages";
symbolic procedure prinlaend;
<<terpri();
  prin2t "\)\par";
  if !*verbatim then
      <<prin2t "\begin{verbatim}";
        prin2t "REDUCE Input:">>;
  ncharspr!*:=0;
  if ofl!* then linelength(car linel!*)
    else laline!*:=cdr linel!*;
  nochar!*:=append(nochar!*,nochar1!*);
  nochar1!*:=nil >>$
  %
\end{reduce}
Similarly, hardcode at the beginning of expression output
that the mathematics is in inline mode.
\begin{reduce}
symbolic procedure prinlabegin;
% Initializes the output
<<if !*verbatim then
      <<terpri();
        prin2t "\end{verbatim}">>;
  linel!*:=linelength nil . laline!*;
  if ofl!* then linelength(laline!* + 2)
    else laline!*:=car linel!* - 2;
  prin2 "\(" >>$
\end{reduce}

Override the procedure that outputs the \LaTeX\ preamble
upon the command \verb|on latex|. Presumably modified from
that in \verb|rlfi.red|. Use it to write a decent header
that we use for one master file.
\begin{reduce}
symbolic procedure latexon;
<<!*!*a2sfn:='texaeval;
  !*raise:=nil;
  prin2t "\documentclass[11pt,a5paper]{article}";
  prin2t "\usepackage[a5paper,margin=13mm]{geometry}";
  prin2t "\usepackage{parskip,time} \raggedright";
  prin2t "\def\exp\big(#1\big){\,{\rm e}^{#1}}";
  prin2t "\def\eps{\varepsilon}";
  prin2t "\title{Invariant manifold of your dynamical system}";
  prin2t "\author{A. J. Roberts, University of Adelaide\\";
  prin2t "\texttt{http://orcid.org/0000-0001-8930-1552}}";
  prin2t "\date{\now, \today}";
  prin2t "\begin{document}";
  prin2t "\maketitle";
  prin2t "Throughout and generally: the lowest order, most";
  prin2t "important, terms are near the end of each expression.";
  prin2t "\input{invarManReportSys}";
  if !*verbatim then
      <<prin2t "\begin{verbatim}";
        prin2t "REDUCE Input:">>;
  put('tex,'rtypefn,'(lambda(x) 'tex)) >>$
\end{reduce}




End the file when read by Reduce
\begin{reduce}
end;
\end{reduce}

\bibliographystyle{agsm}
\bibliography{bib,ajr}

\end{document}