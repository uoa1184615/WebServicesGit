\documentclass[11pt,a5paper]{article}

\title{Computer algebra derives invariant manifolds and/or
normal forms of general stochastic or non-autonomous
multiscale differential equations}

\author{A.~J. Roberts\thanks{School of Mathematical
Sciences, University of Adelaide, South Australia~5005,
\textsc{Australia}. \url{https://profajroberts.github.io/}}}

\date{November 19, 2008; modified \today}



\usepackage{url,natbib,amsmath,defns,reducecode}
\RaisedNamesfalse
\let\harvardurl\url
\IfFileExists{ajr.sty}{\usepackage{ajr}}{}
\usepackage{mycleveref}
%\allowdisplaybreaks
\def\ou\big(#1,#2,#3\big)%
    {{{\rm e}^{\if#31\else#3\fi t}\star}#1\,}
\newcommand{\Z}[1]{{\rm e}^{#1t}{\star}}
\Vec x\Vec y\Vec z
\Vec X\Vec Y\Vec Z
\newcommand{\sgn}{\operatorname{sgn}}
\newcommand{\res}{\operatorname{Res}}
\def\eps{\ensuremath{\varepsilon}}
\def\sde{\textsc{s/ode}}

\begin{document}
\sloppy

\maketitle

\begin{abstract}
Provides a coded procedure to construct invariant manifolds
or a normal form of a wide class of systems of
non-autonomous or stochastic differential equations (herein
abbreviated by \sde{}s).  The methodology is based upon
earlier research~\cite[]{Cox91, Chao95, Roberts06k}.
Interpret all \sde{}s in the Stratonovich sense so the
analysis applies to deterministic differential equations,
both non-autonomous and autonomous. Cater for deterministic
autonomous systems by simply omitting the `noise'.  For
generality, this coded procedure now caters  for unstable
modes, and for differential equation systems with  a
rational right-hand side.  This code also underlies an
interactive web service~\cite[]{Roberts07d}.  Modelling
stochastic systems has many important applications.  The
constructed stochastic coordinate transforms and associated
invariant manifolds are a powerful way of disentangling
emergent long term dynamics.  
\end{abstract}

\tableofcontents



\section{Introduction}

\paragraph{Installation}
Download and install the computer algebra package
\emph{Reduce} via \url{http://www.reduce-algebra.com}\quad
Download and unzip the folder
\url{https://profajroberts.github.io/StoNormForm.zip} \quad
Within the folder \verb|StoNormForm|, start-up \emph{Reduce}
and load the procedure by executing the command 
\verb|in_tex "stoNormForm.tex"$| \footnote{This script
changes many internal settings of \emph{Reduce}, so best to
do only when needed.} Test your installation by then
executing \verb|examplenormform(csuman);| \quad(see
\cref{ss:eg}).

\paragraph{Execution}
Thereafter, construct a specified invariant manifold\slash
normal form of a specific dynamical system by executing the
following command with specific values for the input
parameters.  See \verb|manyExamples.pdf| for many and varied
examples.
\begin{verbatim}
stonormalform(dxdt, dydt, dzdt, toosmall, theman);
\end{verbatim}


\paragraph{Inputs}
Write your \sde\ system in terms of slow
variables~\(x_j(t)\), fast stable variables~\(y_j(t)\)
(linearly decaying), and fast unstable variables~\(z_j(t)\)
(linearly growing).  For an \sde\ with $n_x$~slow modes,
$n_y$~fast stable modes, and/or \(n_z\)~fast unstable modes,
you must denote the slow modes by~\verb|x(1)| through
to~\verb|x(nx)|, the stable fast modes by~\verb|y(1)|
through to~\verb|y(ny)|, and the unstable fast modes
by~\verb|z(1)| through to~\verb|z(nz)|. Each non-autonomous
factor must be denoted by~\verb|w(.)| where the dot denotes
almost any label you care to choose: simple numbers such
as~\verb|w(1)| and/or~\verb|w(2)| are the usual choices; but
other labels may be used. Often \verb|w(.)| is a
Stratonovich white noise, a derivative of a Stratonovich
Wiener process. Analyse deterministic, autonomous, systems
by omitting any noise term~\verb|w()| in the differential
equations. The \sde{}s must be linearly diagonalised.
\footnote{Although a Jordan form is also acceptable, there
are issues in the error control.  Also, `small' off-diagonal
terms are allowed.}  Then, as in the example of the next
\cref{ss:eg}, the input parameters to the procedure are the
following:
\begin{itemize}
\item \verb|dxdt|, a comma separated list within braces,
\(\{\ldots\}\), of the right-hand sides of the \sde{}s for
the slow variables~\(x_j(t)\) (the list may be
empty~\verb|{}|);

\item \verb|dydt|, a comma separated list within braces,
\(\{\ldots\}\), of the right-hand sides of the \sde{}s for
the fast stable variables~\(y_j(t)\) (the list may be
empty~\verb|{}|);

\item \verb|dzdt|, a comma separated list within braces,
\(\{\ldots\}\), of the right-hand sides of the \sde{}s for
the fast unstable variables~\(z_j(t)\) (the list may be
empty~\verb|{}|);

\item \verb|toosmall|, an integer giving the desired order
of error in the asymptotic approximation that is
constructed.  The procedure embeds the specified system in a
family of systems parametrised by~\(\eps\), and constructs
an invariant manifold\slash normal form, and evolution
thereon, of the embedding system to the asymptotic
error~\Ord{\eps^{\tt toosmall}} (as \(\eps\to0\)).  Often
the introduced artificial~\(\eps\) has a useful physical
meaning, but strictly you should evaluate the output at
\(\eps=1\) to recover results for the specified system, and
then reinterpret the results, and errors, in terms of your
systems actual `small' parameters.

The code \emph{also} truncates to errors~\Ord{\sigma^3}
where \(\sigma\)~characterises the magnitude of the
non-autonomous\slash stochastic effects~\verb|w(j)|.

\item \verb|theman|, \emph{optional}, \emph{one} of the
identifiers in the set \(\{\verb|cman|\C \verb|sman|\C
\verb|uman|\C \verb|csman|\C \verb|cuman|\C
\verb|csuman|\}\) specifying which invariant manifold to
construct: respectively, centre (slow), stable, unstable,
centre-stable, centre-unstable, or a normal form coordinate
transform of the entire centre-stable-unstable space.  If
omitted, then the default is \verb|csuman|.
\end{itemize}

The above right-hand side expressions for the
time-derivatives must be multinomial in variables~$x_i$,
$y_i$, $z_i$~and~$w_i$\,.  To cater for rational function
right-hand sides, one also may include some~\(\dot x_i\),
\(\dot y_i\), \text{and~\(\dot z_i\) factors.}


\paragraph{Outputs}  This procedure reports the embedded
system it actually analyses, the number of iterations taken,
the constructed time dependent coordinate transform (the
original variables~\((\xv,\yv,\zv)\) as a function of the
new variables~\((\Xv,\Yv,\Zv)\)), and the corresponding
evolution in the new variables in terms of \sde{}s
for~\((\Xv,\Yv,\Zv)\).
\begin{itemize}
\item A plain report to the Terminal window in which
\emph{Reduce} is executing.

\item A \LaTeX\ source report written to the file
\verb|stoNFreport.tex| (with \verb|stoNFreportHdr.tex|
and \verb|stoNFreportSys.tex|). Generate a pdf version 
by executing \verb|pdflatex stoNFreport|\,.

\item Global arrays such that \verb|x_(i)|, \verb|y_(j)|,
and~\verb|z_(k)|, respectively, are the normal form
coordinate transforms or invariant manifold coordinates
\(x_i(\Xv,\Yv,\Zv,\sigma,\eps)\),
\(y_j(\Xv,\Yv,\Zv,\sigma,\eps)\),
and~\(z_k(\Xv,\Yv,\Zv,\sigma,\eps)\). Depending upon the
requested invariant manifold, the dependence upon
appropriate ones of~\Xv, \Yv, or~\Zv\ does not exist.

\item Global arrays \verb|ff(i)|, \verb|gg(j)|,
and~\verb|hh(k)| give the corresponding evolution \(\dot
X_i=\verb|ff(i)|\), \(\dot Y_j=\verb|gg(j)|\), and \(\dot
Z_k=\verb|hh(j)|\) ---all as functions
of~\((\Xv,\Yv,\Zv,\sigma,\eps)\), or a subset thereof as
appropriate for the specified invariant manifold.
\end{itemize}
One may change the appearance of the output somewhat. For
example, in order to group terms in output expressions,
execute a \verb|factor| command before executing the
procedure \verb|stonormalform(...)|.


\paragraph{Background}
The theoretical support for the results of the analysis of
this procedure is centre\slash stable\slash unstable
manifold theory \cite[e.g.,][]{Carr81, Knobloch82,
Haragus2011, Roberts2014a}, and an embryonic backwards
theory \cite[]{Roberts2018a}.  This particular procedure is
developed from that for human-efficient computer algebra
\cite[]{Roberts96a}, and extended to stochastic\slash
non-autonomous systems \cite[]{Chao95, Roberts06k}.

We use the computer algebra package \emph{Reduce} 
[\url{http://reduce-algebra.com/}] because it is both free 
and perhaps the fastest general purpose computer algebra 
system~\cite[e.g.]{Fateman2002}.



\subsection{A simple example: \texttt{examplenormform()}} 
\label{ss:eg}
Execute this example by invoking the command
\verb|examplenormform(csuman);|\quad The classically basic
non-trivial system of fast/slow \sde{}s
\cite[\S19.1]{Roberts2014a} is
\begin{equation*}
\dot x=-xy \qtq{and} \dot y=-y+x^2-2y^2+\sigma w(t),
\end{equation*}
where lowercase~$w(t)$, called a \emph{noise} within this
document, often denotes the formal derivative~$dW/dt$ of a
Stratonovich Wiener process~$W(t,\omega)$. Alternatively,
\(w(t)\)~represents an arbitrary deterministic
time-dependent forcing, or some control, or some `coloured'
random process, or some other extrinsic input to the system.
Parameter~$\sigma$ controls the strength of the so-called
noise.

Use slow variable~\verb|x(1)| to denote~$x(t)$, stable
variable~\verb|y(1)| to denote~$y(t)$, there is no unstable
variable in this \sde, and use \verb|w(1)| to denote the
(Stratonovich) noise~$w$.  Hence this system is analysed for
`small'~\((x,y,\sigma)\) by executing the following defined
procedure \verb|examplenormform()|:
\begin{reduce}
procedure examplenormform(theman);  
    stonormalform(
    {-x(1)*y(1)},
    {-y(1)+x(1)^2-2*y(1)^2+w(1)},
    {},
    3, theman )$
\end{reduce}
The procedure \verb|stonormalform| automatically multiplies
the noise factors by a parameter~\verb|sigma| so there is no
need include the parameter~$\sigma$ in the specification of
the problem---it will be done for you.

Further, the procedure uses the parameter~\verb|small|, often
denoted by~\(\eps\), to control truncation in nonlinearity. 
The fourth parameter in the above specifies to construct the
normal form to errors~\Ord{\eps^3}.

Consequently, the procedure embeds the given system as the
\(\eps=1\) version of the following system that it actually
analyses:
\begin{equation*}
\dot x_{1}=-\eps x_{1} y_{1} 
\qtq{and} 
\dot y_{1}=\sigma  w_{1}+\eps \big(x_{1}^{2}-2
y_{1}^{2}\big)-y_{1}
\end{equation*}
using analysis and theory based upon the subspace of
equilibria \(y_1=\eps=\sigma=0\)\,.  The constructed
coordinate transform and corresponding \sde{}s are the
following.


\paragraph{The stochastic coordinate transform} (to one
order lower in both~\(\eps\) and~\(\sigma\) than actually
constructed)
\begin{align*}&
x_{1}=\sigma  \eps \ou\big(w_{1},tt,-1\big) X_{1}+\eps X_{1}
Y_{1}+X_{1}
+O\big(\varepsilon ^{2},\sigma^{2}\big)
\\&
y_{1}=4 \sigma  \eps \ou\big(w_{1},tt,-1\big) Y_{1}+\sigma
\ou\big(w_{1},tt,-1\big)+\eps \big(X_{1}^{2}+2
Y_{1}^{2}\big)+Y_{1}
+O\big(\varepsilon ^{2},\sigma^{2}\big)
\end{align*}


\paragraph{Result normal form SDEs}
\begin{align*}&
\dot X_{1}=2 \sigma ^{2} \eps^{2} \ou\big(w_{1},tt,-1\big)
w_{1} X_{1}- \sigma  \eps w_{1} X_{1}-\eps^{2} X_{1}^{3}
+O\big(\varepsilon ^{3},\sigma^{3}\big)
\\&
\dot Y_{1}=8 \sigma ^{2} \eps^{2} \ou\big(w_{1},tt,-1\big)
w_{1} Y_{1}-4 \sigma  \eps w_{1} Y_{1}-2 \eps^{2} X_{1}^{2}
Y_{1}-Y_{1}
+O\big(\varepsilon ^{3},\sigma^{3}\big)
\end{align*}
\begin{itemize}
\item Since this construction is based upon the subspace of
equilibria \(y_1=\eps=\sigma=0\), these constructed
expressions are asymptotic as \((Y_1,\eps,\sigma)\to0\). 
However, evaluation at \(\eps=1\) typically means that the
expressions should be reinterpreted as asymptotic  as
\((Y_1,X_1,\sigma)\to0\).

Alternatively, since~\eps\ multiplies only quadratic terms, 
then one could view it as counting the order of 
nonlinearity in the new variables~\((X_1,Y_1)\).  For 
example, the errors~\Ord{\eps^3} are equivalent to 
errors~\Ord{|(X_1,Y_1,\sigma)|^4}.  Parameter~\(\sigma\) 
arises in this error because the term~\(\sigma w_1\) drives 
effects of size~\(\sigma\) in~\(y_1\).

\item The \(\dot Y_1\) \sde\ shows that \(Y_1=0\) is exactly
invariant, and since dominantly is \(\dot Y_1 \approx
-Y_1\)\,, then \(Y_1=0\) is almost always exponentially
quickly attractive (emergent) in some domain about the
origin.

\item The \(\dot X_1\) \sde\ is independent of~\(Y_1\) and
here indicates an algebraic attraction to zero, albeit
affected by a multiplicative noise, and moderated by some
irreducible noise-noise interactions.  The independence
of~\(Y_1\) implies that the \(\dot X_1\) \sde\ precisely
predicts the system dynamics from its initial value over all
time.

\item These deductions are transformed into the original
\(xy\)-space by the constructed time-dependent coordinate
transformation.

\item Backwards theory \cite[]{Roberts2018a} would assert
that the \(X_1Y_1\)-system and the coordinate transform, put
together, defines a system in the original \(xy\)-space, a
system that is close to the original specified \sde{}s.
\end{itemize}




\section{Header of the procedure}

Need a couple of things established before defining the
procedure: the \verb|rlfi| package for a nicer version of
the output via \LaTeX; and operator names for the variables
of the \sde{}s.
\begin{reduce}
load_package rlfi; 
operator x;
operator y;
operator z;
operator w;
\end{reduce}
Cater for rational function \sde{}s by allowing time
dependence in these variables at specification. For rational
function \sde{}s, users must multiply each \sde\ by a common
denominator, and put on the right-hand side the nonlinear
terms involving the time derivative.
\begin{reduce}
depend x,t;
depend y,t;
depend z,t;
\end{reduce}

Clear the identifiers used to specify the invariant
manifold\slash normal form.
\begin{reduce}
clear cman,sman,uman,csman,cuman,csuman;
\end{reduce}



Now define the procedure as an operator so we can define
procedures internally, and may be flexible with its
arguments.
\begin{reduce}
operator stonormalform;
for all dxdt, dydt, dzdt, toosmall let
    stonormalform(dxdt, dydt, dzdt, toosmall) 
    = stonormalform(dxdt, dydt, dzdt, toosmall, csuman);
for all dxdt, dydt, dzdt, toosmall, theman let
    stonormalform(dxdt, dydt, dzdt, toosmall, theman) 
    = begin 
\end{reduce}


\subsection{Preamble to the procedure}
Operators and arrays are always global, but we can make
variables and matrices local, except for matrices that need
to be declared \verb|matrix|.  So, move to implement all
arrays and operators to have underscores, and almost all
scalars and most matrices to be declared local here (for
some reason \verb|x/y/zrhs| must be global).
\begin{reduce}
scalar maxiter, trace, nx, ny, nz, offdiag, jac, ok, res,
res0, res1, lengthresx, lengthresy, lengthresz, cmanf,
smanf, umanf, textask;
\end{reduce}

Determine the text of the task.
\begin{reduce}
textask:=if theman=cman then "centre manifold" else
    if theman=sman then "stable manifold" else
    if theman=uman then "unstable manifold" else
    if theman=csman then "centre-stable manifold" else
    if theman=cuman then "centre-unstable manifold" else
    if theman=csuman then "normal form" else
    rederr "cannot recognise the manifold to construct"$
\end{reduce}
Set corresponding flags to be~1 or~0 depending upon whether
that component of the dynamics is to be in the manifold.
\begin{reduce}
procedure inlist(a,b)$ if member(a,b) then 1 else 0$
cmanf := inlist(theman,{cman,csman,cuman,csuman})$
smanf := inlist(theman,{sman,csman,csuman})$
umanf := inlist(theman,{uman,cuman,csuman})$
\end{reduce}


Write an intro message.
\begin{reduce}
write "Construct a stochastic ",textask
     ," (version 16 June 2021)"$
\end{reduce}

Parameter \verb|maxiter|~is the maximum number of allowed
iterations; this default may be changed.
\begin{reduce}
maxiter:=32$
\end{reduce}
In the printed expressions, by default, factor
\verb|small|~(\eps) and \verb|sigma|~($\sigma$).
\begin{reduce}
%factor small,sigma; 
\end{reduce}

The code cannot handle any cubic or higher order in noise amplitude~\verb|sigma|.
\begin{reduce}
let sigma^3=>0;
\end{reduce}

For optional trace printing of test cases: comment out
second line when not needed.
\begin{reduce}
trace:=0$
%trace:=1; maxiter:=5; 
\end{reduce}

The \verb|rationalize| switch may make code much faster with
complex numbers. The switch \verb|gcd| seems to wreck
convergence, so leave it off.
\begin{reduce}
on div; off allfac; on revpri; 
on rationalize;
\end{reduce}







\subsection{Extract and scale slow equations}

The number of slow equations is the number of terms in the
list in~\verb|dxdt|.
\begin{reduce}
xrhs_:=dxdt$
write "no. of slow modes ",nx:=length(xrhs_);
\end{reduce}

Multiply all the right-hand sides by~\verb|small| so we can
control the truncation of the asymptotic construction
through discarding high powers of~\verb|small|. Users could
use~\verb|small| in their equations for appropriate effects.
\begin{reduce}
xrhs_:=for i:=1:nx collect small*part(xrhs_,i)$
\end{reduce}

Adjust the noise terms. Remove the \verb|small|
multiplication of noise terms, and instead multiply
by~\verb|sigma| to empower independent control of the
truncation in noise amplitude.
\begin{reduce}
xrhs_:=(xrhs_ where w(~j)=>sigma*w(j,1)/small)$
xrhs_:=(xrhs_ where w(~j,1)=>w(j))$
\end{reduce}

Section~\ref{sec:dwti} writes the resulting differential
equations for information.
\begin{reduce}
if trace then for i:=1:nx do 
    write "dx(",i,")/dt = ",1*part(xrhs_,i);
\end{reduce}


\subsection{Extract and scale stable fast equations}

The number of stable fast equations is the number of terms
in the list in~\verb|dydt|.
\begin{reduce}
yrhs_:=dydt$
write "no. of stable fast modes ",ny:=length(yrhs_);
\end{reduce}

\paragraph{Extract decay rates}
Extract the linear decay rates of the fast equations into an
array. For each expression in the provided set of right-hand
sides:
\begin{reduce}
clear rats_; array rats_(ny);
for i:=1:ny do begin
\end{reduce}

For the $i$th right-hand side get the linear dependence
upon~\verb|y(i)|, then set other dynamic variables to zero
to get just the coefficient.
\begin{reduce}
  rats_(i):=coeffn(part(yrhs_,i),y(i),1);
  rats_(i):=(rats_(i) where 
      {x(~j)=>0,y(~j)=>0,z(~j)=>0,w(~j)=>0});
\end{reduce}

However, the coefficient may depend upon parameters, so if
it is not simply a number, but is a sum, then trawl through
the sum looking for a simple number to use as the decay
rate.
\begin{reduce}
  if not numberp(rats_(i)) then 
  if part(rats_(i),0)=plus then begin
    rr:=0;
    for j:=1:arglength(rats_(i)) do 
      if numberp(part(rats_(i),j)) 
      then rr:=part(rats_(i),j);
    rats_(i):=rr;
  end;
\end{reduce}

Change sign to make \verb|rats_| into positive decay rates,
rather than negative growth rates.
\begin{reduce}
  rats_(i):=-rats_(i); 
\end{reduce}

If all the above has not ended up with a simple number, then
exit with an error message. 
\begin{reduce}
  if numberp(rats_(i))and rats_(i)>0 then
  else begin 
    write "***** Error *****
    Linear coeffs of y-decay must be negative numbers";
    return;
  end;
\end{reduce}

End the loop over all right-hand sides.
\begin{reduce}
end;
if trace then write "End loop over all dydt";
\end{reduce}

Flag later warning if the linear part not diagonal.
\begin{reduce}
offdiag:=0$
for i:=1:ny do for j:=1:ny do if i neq j then begin
  jac:=coeffn(part(yrhs_,i),y(j),1);
  if (jac where {x(~k)=>0,y(~k)=>0,z(~k)=>0,w(~k)=>0}) neq 0 
  then offdiag:=1$
end;
if trace then write offdiag:=offdiag;
\end{reduce}

Multiply all the `nonlinear' terms right-hand sides
by~\verb|small| so we control the truncation of the
asymptotic construction through discarding high powers
of~\verb|small|. Leave the identified linear decay terms
intact. Users could use~\verb|small| in their equations for
interesting effects. 
\begin{reduce}
yrhs_:=for i:=1:ny collect 
  small*part(yrhs_,i)+(1-small)*(-rats_(i)*y(i))$
\end{reduce}

Remove the \verb|small|~multiplication of noise terms, and
instead multiply by~\verb|sigma| to empower independent
control of the truncation in \text{noise amplitude.}
\begin{reduce}
yrhs_:=( yrhs_ where w(~j)=>sigma*w(j,1)/small )$
yrhs_:=( yrhs_ where w(~j,1)=>w(j) )$
\end{reduce}

\cref{sec:dwti} writes the resulting differential equations
for information.
\begin{reduce}
if trace then for i:=1:ny do 
    write "dy(",i,")/dt = ",1*part(yrhs_,i);
\end{reduce}



\subsection{Extract and scale unstable fast equations}

The number of unstable fast equations is the number of terms
in the list in~\verb|dzdt|.
\begin{reduce}
zrhs_:=dzdt$
write "no. of unstable fast modes ",nz:=length(zrhs_);
\end{reduce}

\paragraph{Extract growth rates}
Extract the linear growth rates of the fast equations into
an array. For each expression in the provided set of
right-hand sides:
\begin{reduce}
clear ratu_; array ratu_(nz);
for i:=1:nz do begin
\end{reduce}

For the $i$th right-hand side get the linear dependence
upon~\verb|z(i)|, then set other dynamic variables to zero
to get just the coefficient.
\begin{reduce}
  ratu_(i):=coeffn(part(zrhs_,i),z(i),1);
  ratu_(i):=(ratu_(i) where 
      {x(~j)=>0,y(~j)=>0,z(~j)=>0,w(~j)=>0});
\end{reduce}

However, the coefficient may depend upon parameters, so if
it is not simply a number, but is a sum, then trawl through
the sum looking for a simple number to use as the growth
rate.
\begin{reduce}
  if not numberp(ratu_(i)) then 
  if part(ratu_(i),0)=plus then begin
    rr:=0;
    for j:=1:arglength(ratu_(i)) do 
      if numberp(part(ratu_(i),j)) 
      then rr:=part(ratu_(i),j);
    ratu_(i):=rr;
  end;
\end{reduce}

If all the above has not ended up with a simple number, then
exit with an error message. 
\begin{reduce}
  if numberp(ratu_(i))and ratu_(i)>0 then
  else begin 
    write "***** Error *****
    Linear coeffs of z-growth must be positive numbers";
    return;
  end;
\end{reduce}

End the loop over all \(z\)-right-hand sides.
\begin{reduce}
end;
if trace then write "End loop over all dzdt";
\end{reduce}

Flag warning if the linear part not diagonal.
\begin{reduce}
for i:=1:nz do for j:=1:nz do if i neq j then begin
  jac:=coeffn(part(zrhs_,i),z(j),1);
  if (jac where {x(~k)=>0,y(~k)=>0,z(~k)=>0,w(~k)=>0}) neq 0 
  then offdiag:=1$
end;
if trace then write offdiag:=offdiag;
\end{reduce}

Multiply all the `nonlinear' terms right-hand sides
by~\verb|small| so we control the truncation of the
asymptotic construction through discarding high powers
of~\verb|small|. Leave the identified linear growth terms
intact. Users could use~\verb|small| in their equations for
interesting effects. 
\begin{reduce}
zrhs_:=for i:=1:nz collect 
  small*part(zrhs_,i)+(1-small)*(+ratu_(i)*z(i))$
\end{reduce}

Remove the \verb|small|~multiplication of noise terms, and
instead multiply by~\verb|sigma| to empower me to
independently control the truncation in noise amplitude.
\begin{reduce} 
zrhs_:=( zrhs_ where w(~j)=>sigma*w(j,1)/small )$
zrhs_:=( zrhs_ where w(~j,1)=>w(j) )$
\end{reduce}

\cref{sec:dwti} writes the resulting differential equations
for information.
\begin{reduce}
if trace then for i:=1:nz do 
    write "dz(",i,")/dt = ",1*part(zrhs_,i);
\end{reduce}








\section{Setup LaTeX output using rlfi}

Use inline math environment so that long lines, the norm,
get line breaks. The command \verb|\raggedright| in the
\LaTeX\ preamble appears the best option for the line
breaking, but \verb|\sloppy| would also work reasonably.
\begin{reduce}
mathstyle math;
\end{reduce}

\paragraph{Define names for \LaTeX\ formatting}

Define some names I use, so that rlfi translates them to
Greek characters in the \LaTeX.
\begin{reduce}
defid small,name="\eps";%varepsilon;
defid alpha,name=alpha;
defid beta,name=beta;
defid gamma,name=gamma;
defid delta,name=delta;
defid epsilon,name=epsilon;
defid varepsilon,name=varepsilon;
defid zeta,name=zeta;
defid eta,name=eta;
defid theta,name=theta;
defid vartheta,name=vartheta;
defid iota,name=iota;
defid kappa,name=kappa;
defid lambda,name=lambda;
defid mu,name=mu;
defid nu,name=nu;
defid xi,name=xi;
defid pi,name=pi;
defid varpi,name=varpi;
defid rho,name=rho;
defid varrho,name=varrho;
defid sigma,name=sigma;
defid varsigma,name=varsigma;
defid tau,name=tau;
defid upsilon,name=upsilon;
defid phi,name=phi;
defid varphi,name=varphi;
defid chi,name=chi;
defid psi,name=psi;
defid omega,name=omega;
defid Gamma,name=Gamma;
defid Delta,name=Delta;
defid Theta,name=Theta;
defid Lambda,name=Lambda;
defid Xi,name=Xi;
defid Pi,name=Pi;
defid Sigma,name=Sigma;
defid Upsilon,name=Upsilon;
defid Phi,name=Phi;
defid Psi,name=Psi;
defid Omega,name=Omega;
\end{reduce}

For the variables names I use, as operators, define how they
appear in the \LaTeX, and also define that their arguments
appear as subscripts.
\begin{reduce}
defindex w(down);
defindex x(down);
defindex y(down);
defindex z(down);
defid xx,name="X";
defid yy,name="Y";
defid zz,name="Z";
defindex xx(down);
defindex yy(down);
defindex zz(down);
defindex hh(down);
defindex gg(down);
defindex ff(down);
\end{reduce}

First use these for the specified dynamical system, later
use them for the normal form equations.
\begin{reduce}
defid hh,name="\dot z";
defid gg,name="\dot y";
defid ff,name="\dot x";
\end{reduce}

The `Ornstein--Uhlenbeck' operator is to translate into a
\LaTeX\ command, see the preamble, that typesets the
convolution in a reasonable manner. The definition of the
\LaTeX\ command is a bit dodgy as convolutions of
convolutions are not printed in the correct order; however, 
convolutions commute so it does not matter.
\begin{reduce}
defid ou,name="\ou";
defindex ou(arg,arg,arg);
\end{reduce}


\paragraph{Write the \LaTeX\ dynamical system}

Because of the way rfli works, to get good quality output to
the \LaTeX\ document, I need to write the algebraic
expressions to a file, then read them back in again. While
being read back in, I send the output to the \LaTeX\ file.
In this convoluted way I avoid extraneous output lines
polluting the \LaTeX. 

Temporarily use these arrays for the right-hand sides of the
dynamical system.
\begin{reduce}
clear ff,gg,hh;
array ff(nx),gg(ny),hh(nz);
\end{reduce}

Write expressions to the file \verb|scratchfile.red| for
later reading. Prepend the expressions with an instruction
to write a heading, and surround the heading with anti-math
mode to cancel the math environment that \text{rlfi puts
in.}
\begin{reduce}
out "scratchfile.red"$
write "off echo;"$  % do not understand why needed in 2021??
write "write ""\)
\paragraph{Specified dynamical system}
\(""$";
for i:=1:nx do write "ff(",i,"):=1*part(xrhs_,",i,");"; 
for i:=1:ny do write "gg(",i,"):=1*part(yrhs_,",i,");";
for i:=1:nz do write "hh(",i,"):=1*part(zrhs_,",i,");"; 
write "end;";
shut "scratchfile.red";
\end{reduce}

Then switch on \LaTeX\ output before writing to file as this
\LaTeX\ file is to be input from the main \LaTeX\ file and
hence does not need a header. The header here gets sent to
the `terminal' instead. Then write to
\verb|stoNFreportSys.tex| the expressions we stored in
\verb|scratchfile.red| as nice \LaTeX.
\begin{reduce}
write "Ignore the following five lines of LaTeX"$
on latex$
out "stoNFreportSys.tex"$
in "scratchfile.red"$
shut "stoNFreportSys.tex"$
off latex$
\end{reduce}



\section{Delayed write of text info}
\label{sec:dwti}

Because it is messy to interleave \LaTeX\ and plain output,
I delay writing anything much in plain text until here.

Write the delayed warning message about off-diagonal terms.
\begin{reduce}
if offdiag then write "
***** Warning ****
Off diagonal linear terms in y- or z- equations 
assumed small.  Answers are rubbish if not 
asymptotically appropriate. "$
\end{reduce}

Write the plain text versions of the dynamical system.
\begin{reduce}
write "no. of slow modes ",nx:=length(xrhs_);
for i:=1:nx do write "dx(",i,")/dt = ",1*part(xrhs_,i);
write "no. of stable fast modes ",ny:=length(yrhs_);
for i:=1:ny do write "dy(",i,")/dt = ",1*part(yrhs_,i);
write "no. of unstable fast modes ",nz:=length(zrhs_);
for i:=1:nz do write "dz(",i,")/dt = ",1*part(zrhs_,i);
\end{reduce}



\section{Represent the noise}

The `noises'~\verb|w| depend upon time. But we find it
useful to discriminate upon the notionally fast time
fluctuations of a noise process, and the notionally ordinary
time variations of the dynamic variables~$x_i$, $y_i$,
and~$z_i$. Thus introduce a notionally fast time
variable~\verb|tt|, which depends upon the ordinary
time~\verb|t|. Equivalently, view~\verb|tt|, a sort of
`partial~$t$', as representing variations in time
independent of those in the variables~$x_i$, $y_i$,
and~$z_i$.
\begin{reduce}
depend w,tt;
depend tt,t,ttyz;
\end{reduce}

In the construction, convolutions of the noise arise, both
backwards over history and also forwards in time to
anticipate the noise \cite[]{Roberts06k, Roberts2018a}. For
any non-zero parameter~$\mu$, define the
`Ornstein--Uhlenbeck' convolution
\begin{equation}
    \Z{\mu}\phi=
    \begin{cases}
        \int_{-\infty}^t \exp[\mu(t-\tau)]\phi(\tau)\,d\tau\,,
        &\mu<0\,, \\
        \int_t^{+\infty} \exp[\mu(t-\tau)]\phi(\tau)\,d\tau\,,
        &\mu>0\,,             
    \end{cases}
    \label{eq:zmuf}
\end{equation}
so that the convolution is always with a bounded
exponential. Five useful properties of this convolution are
\begin{align}&
    \Z\mu1=\frac1{|\mu|}\,,
    \label{eq:conv1}
    \\&
    \frac{d\ }{dt}\Z{\mu}\phi=-\sgn\mu\,\phi+\mu\Z{\mu}\phi\,,
    \label{eq:ddtconv}
    \\&
    E[\Z{\mu}\phi]=\Z{\mu}E[\phi]\,,
    \label{eq:exz}
    \\&
    E[(\Z{\mu}\phi)^2]=\frac1{2|\mu|}\,,
    \label{eq:exzz}
    \\&
    \Z\mu\Z\nu=\begin{cases}
    \frac1{|\mu-\nu|}\big[ \Z\mu+\Z\nu \big]\,, &\mu\nu<0\,, \\
    \frac{-\sgn\mu}{\mu-\nu}\big[ \Z\mu-\Z\nu \big]\,, 
    &\mu\nu>0\ \&\ \mu\neq\nu\,.
    \end{cases}
    \label{eq:twoconv}
\end{align}
Also remember that although with $\mu<0$ the
convolution~$\Z\mu$ integrates over the past, with $\mu>0$
the convolution~$\Z\mu$ integrates into the future---both
over a time scale of order~$1/|\mu|$.

The operator~\verb|ou(f,tt,mu)| represents the
convolution~$\Z\mu f$ as defined by~\eqref{eq:zmuf}: called
\verb|ou| because it is an Ornstein--Uhlenbeck process when
\(f\)~is a stochastic white noise. The operator~\verb|ou| is
`linear' over fast time~\verb|tt| as the convolution only
arises from solving \pde{}s in the operator
$\partial_t-\mu$\,. Code its derivative~\eqref{eq:ddtconv}
and its action upon autonomous terms~\eqref{eq:conv1}:
\begin{reduce}
clear ou; operator ou; linear ou;
let { df(ou(~f,tt,~mu),t)=>-sign(mu)*f+mu*ou(f,tt,mu)
    , ou(1,tt,~mu)=>1/abs(mu)
\end{reduce}
Also code the transform~\eqref{eq:twoconv} that successive
convolutions at different rates may be transformed into
several single convolutions.
\begin{reduce}
    , ou(ou(~r,tt,~nu),tt,~mu) => 
      (ou(r,tt,mu)+ou(r,tt,nu))/abs(mu-nu) when (mu*nu<0)
    , ou(ou(~r,tt,~nu),tt,~mu) => 
      -sign(mu)*(ou(r,tt,mu)-ou(r,tt,nu))/(mu-nu)
      when (mu*nu>0)and(mu neq nu)
    };
\end{reduce}
The above properties are \emph{critical}: they must be
correct for the results to be correct.  Currently, they are
only coded for \emph{real} rates~\(\mu,\nu\).

Second, identify the resonant parts, some of which must go
into the evolution~\verb|gg(i)|, and some into the
transform. It depends upon the exponent of~\verb|yz|
compared to the decay rate of this mode, here~\verb|r|.
\begin{reduce}
clear reso_; operator reso_; linear reso_;
let { reso_(~a,yz,~r)=>1 when df(a,yz)*yz=r*a
    , reso_(~a,yz,~r)=>0 when df(a,yz)*yz neq r*a
    };
\end{reduce}

Lastly, the remaining terms get convolved at the appropriate
rate to solve their respective homological equation by the
operator~\verb|zres_|.
\begin{reduce}
depend yz,ttyz;
clear zres_; operator zres_; linear zres_;
let zres_(~a,ttyz,~r)=>ou(sign(df(a,yz)*yz/a-r)
    *sub(yz=1,a),tt,df(a,yz)*yz/a-r);
\end{reduce}




\section{Operators to solve noisy homological equation}

When solving homological equations of the form
$F+\xi_t=\res$ (the resonant case $\mu=0$), we separate the
terms in the right-hand side~$\res$ into those that are
integrable in fast time, and hence modify the coordinate
transform by changing~$\xi$, and those that are not, and
hence must remain in the evolution by changing~$F$.  the
operator \verb|zint_| extracts those parts of a term that we
know are integrable; the operator \verb|znon_| extracts
those parts which are not knowably bounded integrable. With
more research, more types of terms may be found to be
integrable; hence what is extracted by \verb|zint_| and what
is left by \verb|zint_| may change with more research, or in
different scenarios.  These transforms are not critical:
changing the transforms may change intermediate
computations, but as long as the iteration converges, the
computer algebra results will be algebraically correct.
\begin{reduce}
clear zint_; operator zint_; linear zint_;
clear znon_; operator znon_; linear znon_;
\end{reduce}

First, avoid obvious secularity.
\begin{reduce}
let { zint_(w(~i),tt)=>0, znon_(w(~i),tt)=>w(i)
    , zint_(1,tt)=>0, znon_(1,tt)=>1
    , zint_(w(~i)*~r,tt)=>0, znon_(w(~i)*~r,tt)=>w(i)*r
\end{reduce}
Second, by~\eqref{eq:ddtconv} a convolution may be split
into an integrable part, and a part in its argument which in
turn may be integrable or not.
\begin{reduce}
    , zint_(ou(~r,tt,~mu),tt)
      =>ou(r,tt,mu)/mu+zint_(r,tt)/abs(mu)
    , znon_(ou(~r,tt,~mu),tt)=>znon_(r,tt)/abs(mu)
\end{reduce}
Third, squares of convolutions may be integrated by parts to
an integrable term and a part that may have integrable or
non-integrable parts.
\begin{reduce}
    , zint_(ou(~r,tt,~mu)^2,tt)=>ou(~r,tt,~mu)^2/(2*mu)
                              +zint_(r*ou(r,tt,mu),tt)/abs(mu)
    , znon_(ou(~r,tt,~mu)^2,tt)=>znon_(r*ou(r,tt,mu),tt)/abs(mu)
\end{reduce}
Fourth, different products of convolutions may be similarly
separated using integration by parts.  
\begin{reduce}
    , zint_(ou(~r,tt,~mu)*ou(~s,tt,~nu),tt)
      =>ou(r,tt,mu)*ou(s,tt,nu)/(mu+nu)
      +zint_(sign(mu)*r*ou(s,tt,nu)+sign(nu)*s*ou(r,tt,mu),tt)
      /(mu+nu) when mu+nu neq 0
    , znon_(ou(~r,tt,~mu)*ou(~s,tt,~nu),tt)=>
      +znon_(sign(mu)*r*ou(s,tt,nu)+sign(nu)*s*ou(r,tt,mu),tt)
      /(mu+nu) when mu+nu neq 0
\end{reduce}
However, a zero divisor arises when $\mu+\nu=0$ in the
above. Here code rules to cater for such terms by increasing
the depth of convolutions over past history.
\begin{reduce}
    , zint_(ou(~r,tt,~mu)*ou(~s,tt,~nu),tt)=>
      ou(ou(r,tt,-nu),tt,-nu)*ou(s,tt,nu)
      +zint_(ou(ou(r,tt,-nu),tt,-nu)*s,tt) 
      when (mu+nu=0)and(nu>0)
    , znon_(ou(~r,tt,~mu)*ou(~s,tt,~nu),tt)=>
      znon_(ou(ou(r,tt,-nu),tt,-nu)*s,tt) 
      when (mu+nu=0)and(nu>0)
\end{reduce}
The above handles quadratic products of convolutions.
Presumably, if we seek cubic noise effects then we may need
cubic products of convolutions. However, I do not proceed so
far and hence terminate the separation rules.
\begin{reduce}
};
\end{reduce}




\section{Initialise approximate transform}

Truncate asymptotic approximation of the coordinate
transform depending upon the parameter~\verb|toosmall|. Use
the `instant evaluation' property of a loop index to define
the truncation so that Reduce omits small terms \text{on the
fly.}
\begin{reduce}
for j:=toosmall:toosmall do let small^j=>0;
\end{reduce}

Variables \verb|x|, \verb|y| and~\verb|z| are operators in
the specification of the equations. We now want them to map
to the approximation to the coordinate transform, so point
them to arrays storing the normal form expressions.  Need to
clear the mapping to the array before exiting.
\begin{reduce}
clear x_,y_,z_;
let { x(~j)=>x_(j), y(~j)=>y_(j), z(~j)=>z_(j) };
array x_(nx),y_(ny),z_(nz);
\end{reduce}

Express the normal form in terms of new evolving variables
$X_i$, $Y_i$, and~$Z_i$, denoted by operators \verb|xx(i)|,
\verb|yy(i)| and~\verb|zz(i)|, which are nonlinear
modifications to $x_i$, $y_i$ and~$z_i$. The expressions for
the normal form \sde{}s are stored in~\verb|ff|, \verb|gg|
and~\verb|hh|.
\begin{reduce}
clear xx,yy,zz;
operator xx; operator yy; operator zz;
depend xx,t; depend yy,t; depend zz,t;
let { df(xx(~i),t)=>ff(i)*cmanf 
    , df(yy(~i),t)=>gg(i)*smanf
    , df(zz(~i),t)=>hh(i)*umanf };
\end{reduce}

The first linear approximation is then $x_i\approx X_i$\,,
$y_i\approx Y_i$ and $z_i=Z_i$\,, such that $\dot X_i\approx
0$\,, in~\verb|ff(i)|, $\dot Y_i\approx -r_iY_i$\,,
in~\verb|gg(i)|, and  $\dot Z_i\approx +r_iZ_i$\,,
in~\verb|hh(i)|. Depending upon the specified manifold,
these are multiplied by the appropriate 0-1 flags.
\begin{reduce}
for i:=1:nx do x_(i):=xx(i)*cmanf;
for i:=1:ny do y_(i):=yy(i)*smanf;
for i:=1:nz do z_(i):=zz(i)*umanf;
for i:=1:nx do ff(i):=0;
for i:=1:ny do gg(i):=-rats_(i)*yy(i)*smanf;
for i:=1:nz do hh(i):=+ratu_(i)*zz(i)*umanf;
\end{reduce}

Consider updating the $Y_i$~evolution \verb|gg(i)| and the
$y_i$~transform.  The residual is of the form of a sum of
terms $\prod_{j}Y_j^{q_j}Z_k^{r_k} \in\res$. So updates
involve dividing by, or convolving with, $\beta_i -\sum_j
\beta_j q_j +\sum_k \gamma_k r_k$. First, form the
substitutions needed to introduce~\verb|yz| to count the
number of variables $Y_i$~and~$Z_i$ in any given term,
weighted according to their rate coefficient in the
\text{homological equation.}
\begin{reduce}
y4y:=for i:=1:ny collect yy(i)=yy(i)*yz^rats_(i)$
z4z:=for i:=1:nz collect zz(i)=zz(i)/yz^ratu_(i)$
y4y:=append(y4y,z4z)$
\end{reduce}




\section{Iterative updates}

We iterate to a solution of the governing \sde{}s to
residuals of some order of error. The number of iterations
are limited by a maximum.
\begin{reduce}
for iter:=1:maxiter do begin
  ok:=1;
  if trace then write "
  ITERATION = ",iter,"
  -------------";
\end{reduce}



\subsection{Fast stable modes}

Compute the residual of each of the $y_i$~\sde{}s, updating
\verb|ok| to track whether all \sde{}s are satisfied.  Keep
track of the lengths of the residuals to indicate progress
in the iteration.
\begin{reduce}
  lengthresy:={};
  for i:=1:ny do begin  
    res:=-df(y(i),t)+part(yrhs_,i);
    ok:=if res=0 then ok else 0;
    lengthresy:=append(lengthresy,{length(res)});
    if trace then write "resy",i," = ",res;
\end{reduce}
Within the loop: first insert the weighted count of
$Y$~and~$Z$ variables; then split the residual into two
parts of possibly resonant, \verb|res0| and the
rest,~\verb|res1|; then allocate to the evolution or the
transform.
\begin{reduce}
    res:=sub(y4y,res);
    res0:=reso_(res,yz,+rats_(i));
    res1:=res-res0*yz^rats_(i);
    if smanf then gg(i):=gg(i)+znon_(res0,tt)
    else if znon_(res0,tt) neq 0 
        then rederr("oops y-res: contact me");
    if trace then write "dY",i,"/dt = ",gg(i);
    y_(i):=y_(i) +zint_(res0,tt) -zres_(res1,ttyz,rats_(i));
    if trace then write "y",i," = ",y(i);
  end;
  if ny>0 then write lengthresy:=lengthresy;
\end{reduce}



\subsection{Fast unstable modes}

Compute the residual of each of the $z_i$~\sde{}s, updating
\verb|ok| to track whether all \sde{}s are satisfied.  Keep
track of the lengths of the residuals to indicate progress
in the iteration.
\begin{reduce}
  lengthresz:={};
  for i:=1:nz do begin  
    res:=-df(z(i),t)+part(zrhs_,i);
    ok:=if res=0 then ok else 0;
    lengthresz:=append(lengthresz,{length(res)});
    if trace then write "resz",i," = ",res;
\end{reduce}
Update the $Z_i$~evolution \verb|hh(i)| and the
$z_i$~transform. Within the loop: first insert the weighted
count of $Y$~and~$Z$ variables; then split the residual into
two parts of possibly resonant,~\verb|res0|, and the
rest,~\verb|res1|; then allocate to the evolution or the
transform.
\begin{reduce}
    res:=sub(y4y,res);
    res0:=reso_(res,yz,-ratu_(i));
    res1:=res-res0/yz^ratu_(i);
    if umanf then hh(i):=hh(i)+znon_(res0,tt)
    else if znon_(res0,tt) neq 0 
        then rederr("oops z-res: contact me");
    z_(i):=z_(i) +zint_(res0,tt) -zres_(res1,ttyz,-ratu_(i));
  end;
  if nz>0 then write lengthresz:=lengthresz;
\end{reduce}





\subsection{Slow modes}

Compute the residual of each of the $x$~\sde{}s, updating
\verb|ok| to track whether all \sde{}s are satisfied.  Keep
track of the lengths of the residuals to indicate progress
in the iteration.
\begin{reduce}
  lengthresx:={};
  for i:=1:nx do begin
    res:=-df(x(i),t) +part(xrhs_,i);
    ok:=if res=0 then ok else 0;
    lengthresx:=append(lengthresx,{length(res)});
    if trace then write "resx",i," = ",res;
\end{reduce}
Update the $X_i$~evolution \verb|ff(i)| and the
$x_i$~transform. Use the same process as for the fast
variables; the difference is that here the mode rate is
zero.
\begin{reduce}
    res:=sub(y4y,res);
    res0:=reso_(res,yz,0);
    res1:=res-res0;
    if cmanf then ff(i):=ff(i)+znon_(res0,tt)
    else if znon_(res0,tt) neq 0 then begin
        write "**** Requested manifold may not exist due to";
        write "slow x-residual component: res0=",res0;
        write "**** So halving the max number of iterations";
        maxiter:=maxiter/2;
    end;
    if trace then write "dX",i,"/dt = ",ff(i);
    x_(i):=x_(i) +zint_(res0,tt) -zres_(res1,ttyz,0);
    if trace then write "x",i," = ",x(i);
  end;
  if nx>0 then write lengthresx:=lengthresx;
\end{reduce}

Terminate the iteration loop once all residuals are zero,
or the maximum number of iterations has been done.
\begin{reduce}
  showtime;
  if ok then write "Number of iterations ",
    iter:=1000000+iter;
end;
\end{reduce}





\section{Output results}

Only proceed to print if terminated successfully.
\begin{reduce}
if ok 
  then write "SUCCESS: converged to an expansion"
  else <<write "FAILED TO CONVERGE; I EXIT";
    return; >>;
\end{reduce}


\subsection{Plain text version}

Print the resultant coordinate transform: but only print to
one lower power in~\verb|small| and~\verb|sigma| in order to
keep output relatively small.
\begin{reduce}
write "Stochastic/non-autonomous ",textask," coordinates"$
write "(to one order lower in both small and sigma)"$
for i:=1:nz do if trace then write z_(i):=z_(i)
    else begin z_(i):=sigma*small*z_(i); 
         write z_(i):=z_(i)/small/sigma; end;
for i:=1:ny do if trace then write y_(i):=y_(i) 
    else begin y_(i):=sigma*small*y_(i); 
         write y_(i):=y_(i)/small/sigma; end;
for i:=1:nx do if trace then write x_(i):=x_(i) 
    else begin x_(i):=sigma*small*x_(i); 
         write x_(i):=x_(i)/small/sigma; end;
\end{reduce}

Lastly print the normal form \sde{}s: first the fast, second
the slow.
\begin{reduce}
write "The ",textask," S/ODEs";
if umanf then for i:=1:nz do write "dzz(",i,")/dt = ",hh(i);
if smanf then for i:=1:ny do write "dyy(",i,")/dt = ",gg(i);
if cmanf then for i:=1:nx do write "dxx(",i,")/dt = ",ff(i);
\end{reduce}



\subsection{\LaTeX\ version}

Include order of error to make printing more robust. But we
cannot use \verb|small^toosmall| in the following as that is
set to zero (for the asymptotics), so we hard code that
\verb|small| appears as \verb|varepsilon|~\(\varepsilon\). 
Further, to avoid \verb|sigma^3| being replaced by zero,
introduce \verb|sigma_| that maps to~\(\sigma\).
\begin{reduce}
clear order_;  operator order_;
defid order_,name="O";
defindex order_(arg,arg);
defid sigma_,name="\sigma";
\end{reduce}


As before, we have to write expressions to file for later
reading so they get printed without extraneous dross in the
\LaTeX\ source. First open up the temporary file
\verb|scratchfile.red| again.
\begin{reduce}
out "scratchfile.red"$
write "off echo;"$ % do not understand why needed in 2021??
\end{reduce}

Write the stochastic coordinate transform to file, with a
heading, and with an anti-math environment to cancel the
auto-math of rlfi. For some reason we have to keep these
writes short as otherwise it generates spurious fatal
blank lines in the \LaTeX.
\begin{reduce}
write "write ""\)
\paragraph{Time dependent ",textask," coordinates}
\("";";
for i:=1:nz do write "z_(",i,"):=z_(",i,
    ") +order_(varepsilon^",toosmall-1,",sigma_^2);"; 
for i:=1:ny do write "y_(",i,"):=y_(",i,
    ") +order_(varepsilon^",toosmall-1,",sigma_^2);";
for i:=1:nx do write "x_(",i,"):=x_(",i,
    ") +order_(varepsilon^",toosmall-1,",sigma_^2);"; 
\end{reduce}

Write the resultant stochastic normal form to file, with a
heading, and with an anti-math environment to cancel the
auto-math of rlfi.
\begin{reduce}
write "write ""\)
\paragraph{Result ",textask," DEs}
\("";";
if umanf then for i:=1:nz do write "hh(",i,"):=hh(",i,
    ") +order_(varepsilon^",toosmall,",sigma_^3);";
if smanf then for i:=1:ny do write "gg(",i,"):=gg(",i,
    ") +order_(varepsilon^",toosmall,",sigma_^3);";
if cmanf then for i:=1:nx do write "ff(",i,"):=ff(",i,
    ") +order_(varepsilon^",toosmall,",sigma_^3);";
write "end;";
\end{reduce}

Shut the temporary output file.
\begin{reduce}
shut "scratchfile.red";
\end{reduce}

Get expressions from file and write the main \LaTeX\ file.
But first redefine how these names get printed, namely as
the normal form time derivatives. 
\begin{reduce}
defid x_,name="x"; defindex x_(down);
defid y_,name="y"; defindex y_(down);
defid z_,name="z"; defindex z_(down);
defid hh,name="\dot Z";
defid gg,name="\dot Y";
defid ff,name="\dot X";
\end{reduce}

Penultimately, write the header information file that is 
to be included in the report via an \verb|\input| in the 
modified \verb|on latex|.
\begin{reduce}
out "stoNFreportHdr.tex"$
write "\title{A ",textask," of your dynamical system}"$
write "\author{A. J. Roberts, University of Adelaide\\
\texttt{http://orcid.org/0000-0001-8930-1552}}
\date{\now, \today}
\def\ou\big(#1,#2,#3\big)%
    {{{\rm e}^{\if#31\else#3\fi t}\star}#1\,}
\def\eps{\varepsilon}
\maketitle
Generally, the lowest order, most important,
terms are near the end of each expression.
\input{stoNFreportSys}
"$
shut "stoNFreportHdr.tex"$
\end{reduce}


Finally write to the main \LaTeX\ file so switch on latex
after starting to write to the file. Then write expressions
in \verb|scratchfile.red| to \verb|stoNFreport.tex| as nice
\LaTeX. Switch off latex, to get the end of the document,
and finish writing.
\begin{reduce}
out "stoNFreport.tex"$
on latex$
in "scratchfile.red"$
off latex$
shut "stoNFreport.tex"$
\end{reduce}


\section{Fin}
That's all folks, so end the procedure, after clearing the
mapping from operators to the stored expressions. 
\begin{reduce}
clear x(~j),y(~j),z(~j);
if theman=csuman 
then return Finished_constructing_normal_form_of_system 
else return Finished_invariant_manifold_of_system$ 
end$
\end{reduce}





\section{Override some rlfi procedures}

Now setup the rlfi package to write a \LaTeX\ version of the
output. It is all a bit tricky and underhand. We override
some stuff from \verb|rlfi.red|.\footnote{Find it in
\url{reduce-algebra/trunk/packages/misc/rlfi.red}}  

First, change \verb|name| to get Big delimiters, not
left-right delimiters, so \LaTeX\ can break lines.
\begin{reduce}
deflist('((!( !\!b!i!g!() (!) !\!b!i!g!)) (!P!I !\!p!i! )
     (!p!i !\!p!i! ) (!E !e) (!I !i) (e !e) (i !i)),'name)$
\end{reduce}

Override the procedure that prints annoying messages about
multicharacter symbols. It ends the output of one
expression. This is mainly a copy from \verb|rlfi.red| with
the appropriate if-statement deleted.
\begin{reduce}
symbolic procedure prinlaend;
<<terpri();
  prin2t "\)\par";
  if !*verbatim then
      <<prin2t "\begin{verbatim}";
        prin2t "REDUCE Input:">>;
  ncharspr!*:=0;
  if ofl!* then linelength(car linel!*)
    else laline!*:=cdr linel!*;
  nochar!*:=append(nochar!*,nochar1!*);
  nochar1!*:=nil >>$
\end{reduce}
Similarly, hardcode at the beginning of expression output
that the mathematics is in inline mode.
\begin{reduce}
symbolic procedure prinlabegin;
<<if !*verbatim then
      <<terpri();
        prin2t "\end{verbatim}">>;
  linel!*:=linelength nil . laline!*;
  if ofl!* then linelength(laline!* + 2)
    else laline!*:=car linel!* - 2;
  prin2 "\(" >>$
\end{reduce}

Override the procedure that outputs the \LaTeX\ preamble
upon the command \verb|on latex|.
\begin{reduce}
symbolic procedure latexon;
<<!*!*a2sfn:='texaeval;
  !*raise:=nil;
  prin2t "\documentclass[11pt,a5paper]{article}";
  prin2t "\usepackage[a5paper,margin=13mm]{geometry}";
  prin2t "\usepackage{parskip,time} \raggedright";
  prin2t "\begin{document}\input{stoNFreportHdr}";
  if !*verbatim then
      <<prin2t "\begin{verbatim}";
        prin2t "REDUCE Input:">>;
  put('tex,'rtypefn,'(lambda(x) 'tex)) >>$
\end{reduce}

End the file when input to Reduce
\begin{reduce}
end;
\end{reduce}






\bibliographystyle{agsm}
\bibliography{ajr,bib}


\end{document}
 
